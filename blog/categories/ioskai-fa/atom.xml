<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios开发 | 小孩的技术博客]]></title>
  <link href="http://strivingboy.github.io/blog/categories/ioskai-fa/atom.xml" rel="self"/>
  <link href="http://strivingboy.github.io/"/>
  <updated>2015-09-27T21:05:16+08:00</updated>
  <id>http://strivingboy.github.io/</id>
  <author>
    <name><![CDATA[strivingboy]]></name>
    <email><![CDATA[striving_boy@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS 手势（UIGestureRecognizer）操作]]></title>
    <link href="http://strivingboy.github.io/blog/2014/11/15/ios-gestures/"/>
    <updated>2014-11-15T14:14:19+08:00</updated>
    <id>http://strivingboy.github.io/blog/2014/11/15/ios-gestures</id>
    <content type="html"><![CDATA[<p>本文摘自：<a href="http://www.appcoda.com/ios-gesture-recognizers/">AppCoda</a></p>

<p>UIKit中包含了UIGestureRecognizer类来处理手势识别，UIGestureRecognizer是一个抽象类，用于检测发生在UIView上预定义的手势。UIGestureRecognizer 提供了一些子类来处理具体的手势行为，如下：</p>

<ul>
<li><p>UITapGestureRecognizer: 该类处理View上的点击<em>Tap</em>操作（任意手指、任意次数的点击）该操作很常见</p></li>
<li><p>UISwipeGestureRecognizer: 该类处理滑动<em>Swipe</em>操作（上、下、左、右）如：照片应用中滑动查看下一张照片</p></li>
<li><p>UIPanGestureRecognizer: 该类处理拖拽<em>Pan</em>操作，如：将一个View从一个点拖拽到另一个点</p></li>
</ul>


<!--more-->


<ul>
<li><p>UIPinchGestureRecognizer: 该类处理向里或向外捏和<em>Pinch</em>操作 (任意方向)如：放大或缩小某张图片</p></li>
<li><p>UIRotationGestureRecognizer: 该类处理旋转<em>Rotation</em>操作，如：双指旋转某个view</p></li>
<li><p>UILongPressGestureRecognizer: 该类处理长按<em>LongPress</em>操作</p></li>
<li><p>UIScreenEdgePanGestureRecognizer:该类是ios7上添加的，看起来像<em>Pan</em>手势,它是检测屏幕边缘的pan手势的，系统在某些controller转场的时候会使用这个手势。</p></li>
</ul>


<p>所有的手势对象都会执行<em>perform</em>一个响应事件<em>action</em>,手势对象会带有相关属性设置，如：手指数目，点击次数等，我们将手势处理事件定义如下：</p>

<pre><code>    -(void)handleMyTapGestureWithGestureRecognizer:(UITapGestureRecognizer *)gestureRecognizer;
</code></pre>

<p>下面简单说下各个手势的例子，详细代码请查看原文,在原文demo上我添加了UIScreenEdgePanGestureRecognizer的例子,见github：<a href="https://github.com/strivingboy/GestureDemo.git">GestureDemo</a>。</p>

<ul>
<li>UITapGestureRecognizer 代码片段</li>
</ul>


<p>初始化手势：</p>

<pre><code class="objective-c">
    // 创建 单个手指单次点击 手势对象
    UITapGestureRecognizer *singleTapGestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(handleSingleTapGesture:)];
    [self.testView addGestureRecognizer:singleTapGestureRecognizer];

    // 创建 双手指两次点击 手势对象
    UITapGestureRecognizer *doubleTapGestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(handleDoubleTapGesture:)];
    doubleTapGestureRecognizer.numberOfTapsRequired = 2;
    doubleTapGestureRecognizer.numberOfTouchesRequired = 2;
    [self.testView addGestureRecognizer:doubleTapGestureRecognizer];
</code></pre>

<p>手势响应事件</p>

<pre><code class="objective-c">
    -(void)handleSingleTapGesture:(UITapGestureRecognizer *)tapGestureRecognizer
    {
        // 处理单次点击事件
        ...
    }
    -(void)handleDoubleTapGesture:(UITapGestureRecognizer *)tapGestureRecognizer
    {
        // 处理双手指两次点击事件
        ...
    }
</code></pre>

<ul>
<li>UISwipeGestureRecognizer 代码片段</li>
</ul>


<p>初始化手势：</p>

<pre><code class="objective-c">
    // 创建 滑动 手势对象
    UISwipeGestureRecognizer *swipeRightOrange = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(slideToRightWithGestureRecognizer:)];
    // 滑动方向
    swipeRightOrange.direction = UISwipeGestureRecognizerDirectionRight;

    [self.viewOrange addGestureRecognizer:swipeRightOrange];
</code></pre>

<p>手势响应事件</p>

<pre><code class="objective-c">
    -(void)slideToRightWithGestureRecognizer:(UISwipeGestureRecognizer *)gestureRecognizer
    {
        // 处理向右滑动事件
        ...
    }
</code></pre>

<ul>
<li>UIPanGestureRecognizer 代码片段</li>
</ul>


<p>初始化手势：</p>

<pre><code class="objective-c">
    // 创建 拖拽 手势对象
    UIPanGestureRecognizer *panGestureRecognizer = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(moveViewWithGestureRecognizer:)];
    [self.testView addGestureRecognizer:panGestureRecognizer];
</code></pre>

<p>手势响应事件</p>

<pre><code class="objective-c">
    -(void)moveViewWithGestureRecognizer:(UIPanGestureRecognizer *)panGestureRecognizer
    {
        // 处理拖拽事件
        ...
    }
</code></pre>

<ul>
<li>UIPinchGestureRecognizer 代码片段</li>
</ul>


<p>初始化手势：</p>

<pre><code class="objective-c">
    // 创建 捏合 手势对象
    UIPinchGestureRecognizer *pinchGestureRecognizer = [[UIPinchGestureRecognizer alloc] initWithTarget:self action:@selector(handlePinchWithGestureRecognizer:)];
    [self.testView addGestureRecognizer:pinchGestureRecognizer];
</code></pre>

<p>手势响应事件</p>

<pre><code class="objective-c">
    -(void)handlePinchWithGestureRecognizer:(UIPinchGestureRecognizer *)pinchGestureRecognizer
    {
        // 处理捏合事件
        ...
    }
</code></pre>

<ul>
<li>UIRotationGestureRecognizer 代码片段</li>
</ul>


<p>初始化手势：</p>

<pre><code class="objective-c">
    // 创建 旋转 手势对象
    UIRotationGestureRecognizer *rotationGestureRecognizer = [[UIRotationGestureRecognizer alloc] initWithTarget:self action:@selector(handleRotationWithGestureRecognizer:)];
    [self.testView addGestureRecognizer:rotationGestureRecognizer];
</code></pre>

<p>手势响应事件</p>

<pre><code class="objective-c">
    -(void)handleRotationWithGestureRecognizer:(UIRotationGestureRecognizer *)rotationGestureRecognizer
    {
        // 处理旋转事件
        ...
    }
</code></pre>

<ul>
<li>UILongPressGestureRecognizer 代码片段</li>
</ul>


<p>初始化手势：</p>

<pre><code class="objective-c">
    // 创建 长按 手势对象
    UILongPressGestureRecognizer *longPressGestureRecognizer = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(handleLongPressWithGestureRecognizer:)];
    [self.testView addGestureRecognizer:longPressGestureRecognizer];
</code></pre>

<p>手势响应事件</p>

<pre><code class="objective-c">
    -(void)handleLongPressWithGestureRecognizer:(UILongPressGestureRecognizer *)longPressGestureRecognizer
    {
        // 处理长按事件
        ...
    }
</code></pre>

<ul>
<li>UIScreenEdgePanGestureRecognizer 代码片段</li>
</ul>


<p>初始化手势：</p>

<pre><code class="objective-c">
     // 创建屏幕边缘手势(优先级高于其他手势)
    UIScreenEdgePanGestureRecognizer *edgePanGestureRecognizer = [[UIScreenEdgePanGestureRecognizer alloc]
                                                                  initWithTarget:self
                                                                  action:@selector(handleEdgePanWithGestureRecognizer:)];
    edgePanGestureRecognizer.edges = UIRectEdgeLeft;           // 左侧边缘响应
    [self.view addGestureRecognizer:edgePanGestureRecognizer]; // view添到self.view上
</code></pre>

<p>手势响应事件</p>

<pre><code class="objective-c">
    -(void)handleEdgePanWithGestureRecognizer:(UIScreenEdgePanGestureRecognizer *)gesture
    {
        if(UIGestureRecognizerStateBegan == gesture.state ||
           UIGestureRecognizerStateChanged == gesture.state)
        {
            // 根据被触摸手势的view计算得出坐标值
            CGPoint translation = [gesture translationInView:gesture.view];
            _showView.center = CGPointMake(self.view.bounds.size.width / 2 + translation.x, self.view.bounds.size.height);
        }
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS使用AVFoundation实现二维码扫描]]></title>
    <link href="http://strivingboy.github.io/blog/2014/11/08/scan-qrcode/"/>
    <updated>2014-11-08T14:30:57+08:00</updated>
    <id>http://strivingboy.github.io/blog/2014/11/08/scan-qrcode</id>
    <content type="html"><![CDATA[<p>关于二维码扫描有不少优秀第三方库如：</p>

<ul>
<li><p><a href="http://zbar.sourceforge.net/iphone/sdkdoc/index.html">ZBar SDK</a> 里面有详细的文档，相应介绍也非常多，如：<u><a href="http://rdcworld-iphone.blogspot.in/2013/03/how-to-use-barcode-scanner-br-and-qr-in.html">http://rdcworld-iphone.blogspot.in/2013/03/how-to-use-barcode-scanner-br-and-qr-in.html</a></u></p></li>
<li><p><a href="https://github.com/zxing/zxing">ZXing</a> google推出的开源项目，相应介绍如：<u><a href="http://blog.devtang.com/blog/2012/12/23/use-zxing-library/">http://blog.devtang.com/blog/2012/12/23/use-zxing-library/</a></u></p></li>
</ul>


<p>最近项目需要，看了下使用ios7自带的 AVFoundation Framework 来实现二维码扫描，Demo 见：<a href="https://github.com/strivingboy/scan_qrcode_demo.git">scan_qrcode_demo</a></p>

<p><strong>关于AVFoundation</strong></p>

<!--more-->


<p>AVFoundation 是一个很大基础库，用来创建基于时间的视听媒体，可以使用它来检查,创建、编辑或媒体文件。也可以输入流从设备和操作视频实时捕捉和回放。详细框架介绍见官网：<a href="https://developer.apple.com/library/mac/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/00_Introduction.html">About AV Foundation</a>，本文只是介绍如果使用AVFoundation获取二维码。</p>

<p>首先获取流媒体信息我们需要<code>AVCaptureSession</code>对象来管理输入流和输出流，<code>AVCaptureVideoPreviewLayer</code>对象来显示信息，基本流程如下图所示：</p>

<p><img src="http://strivingboy.github.com/images/2014-11-08-flow.jpg" alt="scan_qr_code_flow" /></p>

<p>注：</p>

<ul>
<li><code>AVCaptureSession</code> 管理输入(AVCaptureInput)和输出(AVCaptureOutput)流，包含开启和停止会话方法。</li>
<li><code>AVCaptureDeviceInput</code> 是AVCaptureInput的子类,可以作为输入捕获会话，用AVCaptureDevice实例初始化。</li>
<li><code>AVCaptureDevice</code> 代表了物理捕获设备如:摄像机。用于配置等底层硬件设置相机的自动对焦模式。</li>
<li><code>AVCaptureMetadataOutput</code> 是AVCaptureOutput的子类，处理输出捕获会话。捕获的对象传递给一个委托实现AVCaptureMetadataOutputObjectsDelegate协议。协议方法在指定的派发队列（dispatch queue）上执行。</li>
<li><code>AVCaptureVideoPreviewLayer</code>CALayer的一个子类，显示捕获到的相机输出流。</li>
</ul>


<p>下面看下实现过程如下：</p>

<p><strong>Step1:</strong>需要导入：AVFoundation Framework 包含头文件：</p>

<pre><code>#import &lt;AVFoundation/AVFoundation.h&gt;
</code></pre>

<p><strong>Step2:设置捕获会话</strong></p>

<p>设置 AVCaptureSession 和 AVCaptureVideoPreviewLayer 成员</p>

<pre><code class="objective-c">
    #import &lt;AVFoundation/AVFoundation.h&gt;

    static const char *kScanQRCodeQueueName = "ScanQRCodeQueue";

    @interface ViewController () &lt;AVCaptureMetadataOutputObjectsDelegate&gt;
    .....
    @property (nonatomic) AVCaptureSession *captureSession;
    @property (nonatomic) AVCaptureVideoPreviewLayer *videoPreviewLayer;
    @property (nonatomic) BOOL lastResult;
    @end
</code></pre>

<p><strong>Step3:创建会话，读取输入流</strong></p>

<pre><code class="objective-c">
    - (BOOL)startReading
    {
        // 获取 AVCaptureDevice 实例
        NSError * error;
        AVCaptureDevice *captureDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];
        // 初始化输入流
        AVCaptureDeviceInput *input = [AVCaptureDeviceInput deviceInputWithDevice:captureDevice error:&amp;error];
        if (!input) {
            NSLog(@"%@", [error localizedDescription]);
            return NO;
        }
        // 创建会话
        _captureSession = [[AVCaptureSession alloc] init];
        // 添加输入流
        [_captureSession addInput:input];
        // 初始化输出流
        AVCaptureMetadataOutput *captureMetadataOutput = [[AVCaptureMetadataOutput alloc] init];
        // 添加输出流
        [_captureSession addOutput:captureMetadataOutput];

        // 创建dispatch queue.
        dispatch_queue_t dispatchQueue;
        dispatchQueue = dispatch_queue_create(kScanQRCodeQueueName, NULL);
        [captureMetadataOutput setMetadataObjectsDelegate:self queue:dispatchQueue];
        // 设置元数据类型 AVMetadataObjectTypeQRCode
        [captureMetadataOutput setMetadataObjectTypes:[NSArray arrayWithObject:AVMetadataObjectTypeQRCode]];

        // 创建输出对象
        _videoPreviewLayer = [[AVCaptureVideoPreviewLayer alloc] initWithSession:_captureSession];
        [_videoPreviewLayer setVideoGravity:AVLayerVideoGravityResizeAspectFill];
        [_videoPreviewLayer setFrame:_sanFrameView.layer.bounds];
        [_sanFrameView.layer addSublayer:_videoPreviewLayer];
        // 开始会话
        [_captureSession startRunning];

        return YES;
    }
</code></pre>

<p><strong>Step4:停止读取</strong></p>

<pre><code class="objective-c">
    - (void)stopReading
    {
        // 停止会话
        [_captureSession stopRunning];
        _captureSession = nil;
    }
</code></pre>

<p><strong>Step5:获取捕获数据</strong></p>

<pre><code class="objective-c">
    -(void)captureOutput:(AVCaptureOutput *)captureOutput didOutputMetadataObjects:(NSArray *)metadataObjects
      fromConnection:(AVCaptureConnection *)connection
    {
        if (metadataObjects != nil &amp;&amp; [metadataObjects count] &gt; 0) {
            AVMetadataMachineReadableCodeObject *metadataObj = [metadataObjects objectAtIndex:0];
            NSString *result;
            if ([[metadataObj type] isEqualToString:AVMetadataObjectTypeQRCode]) {
                result = metadataObj.stringValue;
            } else {
                NSLog(@"不是二维码");
            }
            [self performSelectorOnMainThread:@selector(reportScanResult:) withObject:result waitUntilDone:NO];
        }
    }
</code></pre>

<p><strong>Step6:处理结果</strong></p>

<pre><code class="objective-c">
    - (void)reportScanResult:(NSString *)result
    {
        [self stopReading];
        if (!_lastResult) {
            return;
        }
        _lastResut = NO;
        UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"二维码扫描"
                                                        message:result
                                                       delegate:nil
                                              cancelButtonTitle:@"取消"
                                              otherButtonTitles: nil];
        [alert show];
        // 以下处理了结果，继续下次扫描
        _lastResult = YES;
    }
</code></pre>

<p>以上基本就是二维码的获取流程，和扫一扫二维码伴随的就是开启系统照明，这个比较简单，也是利用 <code>AVCaptureDevice</code>,请看如下实现：</p>

<pre><code class="objective-c">
    - (void)systemLightSwitch:(BOOL)open
    {
        AVCaptureDevice *device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];
        if ([device hasTorch]) {
            [device lockForConfiguration:nil];
            if (open) {
                [device setTorchMode:AVCaptureTorchModeOn];
            } else {
                [device setTorchMode:AVCaptureTorchModeOff];
            }
            [device unlockForConfiguration];
        }
    }
</code></pre>

<p>以上就是本文介绍的大部分内容，详细代码请看demo <a href="https://github.com/strivingboy/scan_qrcode_demo.git">scan_qrcode_deomo</a></p>

<p>实现过程中遇到一下两个问题：</p>

<p>1、扫描一个二维码，输出流回重复调用，代理方法头文件介绍：</p>

<pre><code class="objective-c">
     /*!
     @method captureOutput:didOutputMetadataObjects:fromConnection:
     .....  
     @discussion
        Delegates receive this message whenever the output captures and emits new objects, as specified by
        its metadataObjectTypes property. Delegates can use the provided objects in conjunction with other APIs
        for further processing. This method will be called on the dispatch queue specified by the output's
        metadataObjectsCallbackQueue property. **This method may be called frequently** so it must be efficient to 
        prevent capture performance problems, including dropped metadata objects.

        Clients that need to reference metadata objects outside of the scope of this method must retain them and
        then release them when they are finished with them.
    */
</code></pre>

<p>代理方法会频繁调用，我暂且用一个标记（@property (nonatomic) BOOL lastResult）表示是否是第一次扫描成功，来处理。</p>

<p>2、AVFoundation
该库不能扫描相册中的二维码图片，不知为啥苹果没有支持，有知道实现的麻烦告诉我哈。</p>

<p><strong> 参考链接 </strong></p>

<ul>
<li><p><u><a href="http://useyourloaf.com/blog/2014/05/13/reading-qr-codes.html">http://useyourloaf.com/blog/2014/05/13/reading-qr-codes.html</a></u></p></li>
<li><p><u><a href="http://www.appcoda.com/qr-code-ios-programming-tutorial/">http://www.appcoda.com/qr-code-ios-programming-tutorial/</a> </u></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ios 8 Touch ID 使用]]></title>
    <link href="http://strivingboy.github.io/blog/2014/09/23/touchid-use/"/>
    <updated>2014-09-23T13:14:06+08:00</updated>
    <id>http://strivingboy.github.io/blog/2014/09/23/touchid-use</id>
    <content type="html"><![CDATA[<h2>Touch ID 介绍</h2>

<p>参考：<u><a href="http://www.imore.com/touch-id-ios-8-explained">http://www.imore.com/touch-id-ios-8-explained</a> </u></p>

<h2>Touch ID API</h2>

<p>前提：只有在装有iOS8的真机设备才能编译通过。</p>

<p><strong>Step1).</strong> 使用Touch ID API,首先需要导入:<code>LocalAuthentication.framework</code></p>

<pre><code class="objective-c">    #import &lt;LocalAuthentication/LAContext.h&gt; 
</code></pre>

<!--more-->


<p><strong>Step2).</strong> 使用API，我们需要创建一个Authentication Context</p>

<pre><code class="objective-c">    LAContext *myContext = [[LAContext alloc] init];
</code></pre>

<p><strong>Step3).</strong> 检查当前Touch ID 是否可用,设备没有TouchID或者TouchID未开启返回false，有TouchID并开启返回true.</p>

<pre><code class="objective-c">
    - (BOOL)canEvaluatePolicy:(LAPolicy)policy error:(NSError * __autoreleasing *)error;
</code></pre>

<p><strong>Step4).</strong> 调用显示验证界面
&#8220;`objective-c</p>

<pre><code>- (void)evaluatePolicy:(LAPolicy)policy 
       localizedReason:(NSString *)localizedReason 
                 reply:(void(^)(BOOL success, NSError *error))reply;
</code></pre>

<pre><code>localizedReason：根据官方文档必须提供.

reply:验证成功 success == YES, 否则返回error,根据**error.code**可以得到具体的原因.

在`&lt;LocalAuthentication/LAError.h&gt;`头文件中可以看到如下定义：
</code></pre>

<pre><code>typedef NS_ENUM(NSInteger, LAError)
{
    /// Authentication was not successful, because user failed to provide valid credentials.
    LAErrorAuthenticationFailed = kLAErrorAuthenticationFailed,

    /// Authentication was canceled by user (e.g. tapped Cancel button).
    LAErrorUserCancel           = kLAErrorUserCancel,

    /// Authentication was canceled, because the user tapped the fallback button (Enter Password).
    LAErrorUserFallback         = kLAErrorUserFallback,

    /// Authentication was canceled by system (e.g. another application went to foreground).
    LAErrorSystemCancel         = kLAErrorSystemCancel,

    /// Authentication could not start, because passcode is not set on the device.
    LAErrorPasscodeNotSet       = kLAErrorPasscodeNotSet,

    /// Authentication could not start, because Touch ID is not available on the device.
    LAErrorTouchIDNotAvailable  = kLAErrorTouchIDNotAvailable,

    /// Authentication could not start, because Touch ID has no enrolled fingers.
    LAErrorTouchIDNotEnrolled   = kLAErrorTouchIDNotEnrolled,
} NS_ENUM_AVAILABLE(10_10, 8_0);
</code></pre>

<pre><code>
##Touch ID API 简单封装Demo

**TouchIdUtil.h**
</code></pre>

<pre><code>typedef NS_ENUM(NSInteger, TouchIdEvaluateResult)
{
    kTouchIdEvaluateResultSuccess,   // 验证成功
    kTouchIdEvaluateResultFailed,    // 验证失败
    kTouchIdEvaluateResultCancel,    // 点击取消按钮
    kTouchIdEvaluateResultFallback,  // 点击回退按钮
    kTouchIdEvaluateResultOther      // 未知结果
};

typedef void(^TouchIdEvaluateCallback)(TouchIdEvaluateResult result);

@interface TouchIdUtil : NSObject

+ (instancetype)sharedInstance;

// Touch Id 是否开启或设置
- (BOOL)canEvaluatePolicy;

// Touch Id 验证 callback回调已经抛到了主线程
- (void)evaluatePolicy:(NSString *)localizedReasion
         fallbackTitle:(NSString *)title
              callback:(TouchIdEvaluateCallback)cb;

@end
</code></pre>

<pre><code>**TouchIdUtil.m**
</code></pre>

<pre><code>#import "TouchIdUtil.h"
#import &lt;LocalAuthentication/LocalAuthentication.h&gt;

@implementation TouchIdUtil

+ (instancetype)sharedInstance
{
    static TouchIdUtil* instance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        instance = [[TouchIdUtil alloc] init];
    });
    return instance;
}

- (BOOL)canEvaluatePolicy
{
    LAContext *context = [[LAContext alloc] init];
    NSError *error;
    return [context canEvaluatePolicy: LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&amp;error];
}

- (void)evaluatePolicy:(NSString *)localizedReasion
         fallbackTitle:(NSString *)title
              callback:(TouchIdEvaluateCallback)cb
{
    LAContext *context = [[LAContext alloc] init];
    if (title) {
        context.localizedFallbackTitle = title;
    }

    NSString *myLocalizedReasonString = localizedReasion;
    __weak typeof (self) weakSelf = self;
    [context evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
             localizedReason:myLocalizedReasonString
                       reply:
     ^(BOOL succes, NSError *error) {
         if (succes) {
             [[weakSelf class] reportResultOnUI:kTouchIdEvaluateResultSuccess callback:cb];
         } else {
             switch (error.code) {
                 case LAErrorAuthenticationFailed:
                     [[weakSelf class] reportResultOnUI:kTouchIdEvaluateResultFailed callback:cb];
                     break;
                 case LAErrorUserCancel:
                     [[weakSelf class] reportResultOnUI:kTouchIdEvaluateResultCancel callback:cb];
                     break;
                 case LAErrorUserFallback:
                     [[weakSelf class] reportResultOnUI:kTouchIdEvaluateResultFallback callback:cb];
                     break;
                 default:
                     [[weakSelf class] reportResultOnUI:kTouchIdEvaluateResultOther callback:cb];
                     break;
             }
         }
     }];
}

+ (void)reportResultOnUI:(TouchIdEvaluateResult)result callback:(TouchIdEvaluateCallback)cb
{
    dispatch_async(dispatch_get_main_queue(), ^{
        cb(result);
    });
}

@end
</code></pre>

<p>&#8220;`<br/>
<strong> 问题总结 </strong></p>

<p>1.指纹识别3次错误会弹出系统“输入密码”数字键盘，而且这3次错误机会是系统所有应用共享</p>

<p>2.不要在 <code>evaluatePolicy:</code>方法中调用 <code>canEvaluatePolicy</code> <code>&lt;LocalAuthentication/LAContext.h&gt;</code>中有说明</p>

<p><strong> Demo 见：<a href="https://github.com/strivingboy/touchid.git">TouchIdTest</a></strong></p>

<p><strong> 参考链接 </strong></p>

<ul>
<li><p><u><a href="https://developer.apple.com/library/ios/documentation/LocalAuthentication/Reference/LAContext_Class/index.html#//apple_ref/occ/cl/LAContext">https://developer.apple.com/library/ios/documentation/LocalAuthentication/Reference/LAContext_Class/index.html#//apple_ref/occ/cl/LAContext</a> </u></p></li>
<li><p><u><a href="http://hayageek.com/ios-touch-id-authentication-api/">http://hayageek.com/ios-touch-id-authentication-api/</a> </u></p></li>
</ul>

]]></content>
  </entry>
  
</feed>
