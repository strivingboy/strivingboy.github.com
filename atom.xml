<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[小孩的技术博客]]></title>
  <link href="http://strivingboy.github.io/atom.xml" rel="self"/>
  <link href="http://strivingboy.github.io/"/>
  <updated>2015-10-09T10:24:44+08:00</updated>
  <id>http://strivingboy.github.io/</id>
  <author>
    <name><![CDATA[strivingboy]]></name>
    <email><![CDATA[striving_boy@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[读 iOS核心动画高级技巧]]></title>
    <link href="http://strivingboy.github.io/blog/2015/10/09/ios/"/>
    <updated>2015-10-09T09:42:13+08:00</updated>
    <id>http://strivingboy.github.io/blog/2015/10/09/ios</id>
    <content type="html"><![CDATA[<h3>1、什么是图层和视图？</h3>

<ul>
<li><p>视图：一个视图就是在屏幕上显示的一个矩形块（比如图片，文字或者视频），它能够拦截类似于鼠标点击或者触摸手势等用户输入。视图在层级关系中可以互相嵌套，一个视图可以管理它的所有子视图的位置.在iOS当中，所有的视图都从一个叫做UIVIew的基类派生而来，UIView可以处理触摸事件，可以支持基于Core Graphics绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画。</p></li>
<li><p>图层：CALayer类在概念上和UIView类似，同样也是一些被层级关系树管理的矩形块，同样也可以包含一些内容（像图片，文本或者背景色），管理子图层的位置。它们有一些方法和属性用来做动画和变换。</p></li>
</ul>


<h3>区别:是否处理交互</h3>

<p> CAlayer和UIView最大的不同是CALayer不处理用户的交互。CALayer并不清楚具体的响应链（iOS通过视图层级关系用来传送触摸事件的机制），于是它并不能够响应事件，即使它提供了一些方法来判断是否一个触点在图层的范围之内。</p>

<h3>关系:平行的层级</h3>

<p>每一个UIview都有一个CALayer实例的图层属性，也就是所谓的backing layer，视图的职责就是创建并管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作。图层才是真正用来在屏幕上显示和做动画，UIView仅仅是对它的一个封装，提供了一些iOS类似于处理触摸的具体功能，以及Core Animation底层方法的高级接口。</p>

<!--more-->


<h3>为什么iOS要基于UIView和CALayer提供两个平行的层级关系呢？</h3>

<p>原因在于要做职责分离，这样也能避免很多重复代码。在iOS和Mac OS两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘有着本质的区别，这就是为什么iOS有UIKit和UIView，但是Mac OS有AppKit和NSView的原因。他们功能上很相似，但是在实现上有着显著的区别。</p>

<p>绘图，布局和动画，相比之下就是类似Mac笔记本和桌面系列一样应用于iPhone和iPad触屏的概念。把这种功能的逻辑分开并应用到独立的Core Animation框架，苹果就能够在iOS和Mac OS之间共享代码，使得对苹果自己的OS开发团队和第三方开发者去开发两个平台的应用更加便捷。</p>

<p>实际上，这里并不是两个层级关系，而是四个，每一个都扮演不同的角色，除了视图层级和图层树之外，还存在<strong>呈现树</strong>和<strong>渲染树</strong>。</p>

<h3>2、图层的能力</h3>

<p>如果说CALayer是UIView内部实现细节，那我们为什么要全面地了解它呢？苹果当然为我们提供了优美简洁的UIView接口，那么我们是否就没必要直接去处理Core Animation的细节了呢？</p>

<p>某种意义上说的确是这样，对一些简单的需求来说，我们确实没必要处理CALayer，因为苹果已经通过UIView的高级API间接地使得动画变得很简单。</p>

<p>但是这种简单会不可避免地带来一些灵活上的缺陷。如果你略微想在底层做一些改变，或者使用一些苹果没有在UIView上实现的接口功能，这时除了介入Core Animation底层之外别无选择。</p>

<p>我们已经证实了图层不能像视图那样处理触摸事件，那么他能做哪些视图不能做的呢？这里有一些UIView没有暴露出来的CALayer的功能：</p>

<ul>
<li>阴影，圆角，带颜色的边框</li>
<li>3D变换</li>
<li>非矩形范围</li>
<li>透明遮罩</li>
<li>多级非线性动画</li>
</ul>


<h4>CALayer contents属性</h4>

<p>CALayer 有一个属性叫做contents，这个属性的类型被定义为id，意味着它可以是任何类型的对象。在这种情况下，你可以给contents属性赋任何值，你的app仍然能够编译通过。但是，在实践中，如果你给contents赋的不是CGImage，那么你得到的图层将是空白的。</p>

<p>contents这个奇怪的表现是由Mac OS的历史原因造成的。它之所以被定义为id类型，是因为在Mac OS系统上，这个属性对CGImage和NSImage类型的值都起作用。如果你试图在iOS平台上将UIImage的值赋给它，只能得到一个空白的图层。一些初识Core Animation的iOS开发者可能会对这个感到困惑。</p>

<p>头疼的不仅仅是我们刚才提到的这个问题。事实上，你真正要赋值的类型应该是CGImageRef，它是一个指向CGImage结构的指针。UIImage有一个CGImage属性，它返回一个&#8221;CGImageRef&#8221;,如果你想把这个值直接赋值给CALayer的contents，那你将会得到一个编译错误。因为CGImageRef并不是一个真正的Cocoa对象，而是一个Core Foundation类型。</p>

<p>尽管Core Foundation类型跟Cocoa对象在运行时貌似很像（被称作toll-free bridging），它们并不是类型兼容的，不过你可以通过bridged关键字转换。如果要给图层的寄宿图赋值，你可以按照以下这个方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">layer</span><span class="p">.</span><span class="n">contents</span> <span class="o">=</span> <span class="p">(</span><span class="k">__bridge</span> <span class="kt">id</span><span class="p">)</span><span class="n">image</span><span class="p">.</span><span class="bp">CGImage</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h4>CALayer contentGravity属性</h4>

<p>我们加载的图片被拉伸的问题，解决方法就是把contentMode属性设置成更合适的值，像这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">view</span><span class="p">.</span><span class="n">contentMode</span> <span class="o">=</span> <span class="n">UIViewContentModeScaleAspectFit</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>UIView大多数视觉相关的属性比如<code>contentMode</code>，对这些属性的操作其实是对对应图层的操作。</p>

<p>CALayer与<code>contentMode</code>对应的属性叫做<code>contentsGravity</code>，但是它是一个NSString类型，而不是像对应的UIKit部分，那里面的值是枚举。<code>contentsGravity</code>可选的常量值有以下一些：</p>

<ul>
<li><p>kCAGravityCenter</p></li>
<li><p>kCAGravityTop</p></li>
<li><p>kCAGravityBottom</p></li>
<li><p>kCAGravityLeft</p></li>
<li><p>kCAGravityRight</p></li>
<li><p>kCAGravityTopLeft</p></li>
<li><p>kCAGravityTopRight</p></li>
<li><p>kCAGravityBottomLeft</p></li>
<li><p>kCAGravityBottomRight</p></li>
<li><p>kCAGravityResize</p></li>
<li><p>kCAGravityResizeAspect</p></li>
<li><p>kCAGravityResizeAspectFill</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="nb">self</span><span class="p">.</span><span class="n">layerView</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">contentsGravity</span> <span class="o">=</span> <span class="n">kCAGravityResizeAspect</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#### CALayer maskToBounds属性</span>
</span><span class='line'><span class="err">现在我们的雪人总算是显示了正确的大小，不过你也许已经发现了另外一些事情：它超出了视图的边界。默认情况下，</span><span class="bp">UIView</span><span class="err">仍然会绘制超过边界的内容或是子视图，在</span><span class="bp">CALayer</span><span class="err">下也是这样的。</span>
</span><span class='line'>
</span><span class='line'><span class="bp">UIView</span><span class="err">有一个叫做</span><span class="n">clipsToBounds</span><span class="err">的属性可以用来决定是否显示超出边界的内容，</span><span class="bp">CALayer</span><span class="err">对应的属性叫做</span><span class="n">masksToBounds</span><span class="err">，把它设置为</span><span class="nb">YES</span><span class="err">，就会裁剪掉超过边界的部分。</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#### CALayer contentsRect属性</span>
</span><span class='line'><span class="bp">CALayer</span><span class="err">的</span><span class="n">contentsRect</span><span class="err">属性允许我们在图层边框里显示寄宿图的一个子域。这涉及到图片是如何显示和拉伸的，所以要比</span><span class="n">contentsGravity</span><span class="err">灵活多了</span>
</span><span class='line'>
</span><span class='line'><span class="err">和</span><span class="n">bounds</span><span class="err">，</span><span class="n">frame</span><span class="err">不同，</span><span class="n">contentsRect</span><span class="err">不是按点来计算的，它使用了单位坐标，单位坐标指定在</span><span class="mi">0</span><span class="err">到</span><span class="mi">1</span><span class="err">之间，是一个相对值（像素和点就是绝对值）。所以它们是相对与寄宿图的尺寸的。</span><span class="n">iOS</span><span class="err">使用了以下的坐标系统：</span>
</span><span class='line'>
</span><span class='line'><span class="o">+</span> <span class="err">点</span> <span class="err">——</span> <span class="err">在</span><span class="n">iOS</span><span class="err">和</span><span class="n">Mac</span> <span class="n">OS</span><span class="err">中最常见的坐标体系。点就像是虚拟的像素，也被称作逻辑像素。在标准设备上，一个点就是一个像素，但是在</span><span class="n">Retina</span><span class="err">设备上，一个点等于</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="err">个像素。</span><span class="n">iOS</span><span class="err">用点作为屏幕的坐标测算体系就是为了在</span><span class="n">Retina</span><span class="err">设备和普通设备上能有一致的视觉效果。</span>
</span><span class='line'>
</span><span class='line'><span class="o">+</span> <span class="err">像素</span> <span class="err">——</span> <span class="err">物理像素坐标并不会用来屏幕布局，但是仍然与图片有相对关系。</span><span class="bp">UIImage</span><span class="err">是一个屏幕分辨率解决方案，所以指定点来度量大小。但是一些底层的图片表示如</span><span class="bp">CGImage</span><span class="err">就会使用像素，所以你要清楚在</span><span class="n">Retina</span><span class="err">设备和普通设备上，它们表现出来了不同的大小。</span>
</span><span class='line'>
</span><span class='line'><span class="o">+</span> <span class="err">单位</span> <span class="err">——</span> <span class="err">对于与图片大小或是图层边界相关的显示，单位坐标是一个方便的度量方式，</span> <span class="err">当大小改变的时候，也不需要再次调整。单位坐标在</span><span class="n">OpenGL</span><span class="err">这种纹理坐标系统中用得很多，</span><span class="n">Core</span> <span class="n">Animation</span><span class="err">中也用到了单位坐标。</span>
</span><span class='line'>
</span><span class='line'><span class="err">默认的</span><span class="n">contentsRect</span><span class="err">是</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span><span class="err">，这意味着整个寄宿图默认都是可见的，如果我们指定一个小一点的矩形，图片就会被裁剪</span><span class="p">.</span>
</span><span class='line'><span class="err">事实上给</span><span class="n">contentsRect</span><span class="err">设置一个负数的原点或是大于</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span><span class="err">的尺寸也是可以的。这种情况下，最外面的像素会被拉伸以填充剩下的区域。</span>
</span><span class='line'>
</span><span class='line'><span class="n">contentsRect</span><span class="err">在</span><span class="n">app</span><span class="err">中最有趣的地方在于一个叫做</span><span class="n">image</span> <span class="n">sprites</span><span class="err">（图片拼合）的用法。如果你有游戏编程的经验，那么你一定对图片拼合的概念很熟悉，图片能够在屏幕上独立地变更位置。抛开游戏编程不谈，这个技术常用来指代载入拼合的图片，跟移动图片一点关系也没有。</span>
</span><span class='line'>
</span><span class='line'><span class="err">典型地，图片拼合后可以打包整合到一张大图上一次性载入。相比多次载入不同的图片，这样做能够带来很多方面的好处：内存使用，载入时间，渲染性能等等</span>
</span><span class='line'>
</span><span class='line'><span class="mi">2</span><span class="n">D</span><span class="err">游戏引擎入</span><span class="n">Cocos2D</span><span class="err">使用了拼合技术，它使用</span><span class="n">OpenGL</span><span class="err">来显示图片。不过我们可以使用拼合在一个普通的</span><span class="n">UIKit</span><span class="err">应用中，对！就是使用</span><span class="n">contentsRect</span>
</span><span class='line'>
</span><span class='line'><span class="err">首先，我们需要一个拼合后的图表</span> <span class="err">——</span> <span class="err">一个包含小一些的拼合图的大图片</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="cp">#### CALayer contentsRect属性</span>
</span><span class='line'>
</span><span class='line'><span class="err">`</span><span class="n">contentsCenter</span><span class="err">`其实是一个</span><span class="bp">CGRect</span><span class="err">，它定义了一个固定的边框和一个在图层上可拉伸的区域。</span> <span class="err">改变`</span><span class="n">contentsCenter</span><span class="err">`的值并不会影响到寄宿图的显示，除非这个图层的大小改变了，你才看得到效果。默认情况下，`</span><span class="n">contentsCenter</span><span class="err">`是</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span><span class="err">，这意味着如果大小（由`</span><span class="n">conttensGravity</span><span class="err">`决定）改变了</span><span class="p">,</span><span class="err">那么寄宿图将会均匀地拉伸开</span><span class="p">,</span><span class="err">这意味着我们可以随意重设尺寸，边框仍然会是连续的。它工作起来的效果和</span><span class="bp">UIImage</span><span class="err">里的</span><span class="o">-</span><span class="nl">resizableImageWithCapInsets</span><span class="p">:</span> <span class="err">方法效果非常类似，只是它可以运用到任何寄宿图</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#### Custom Drawing</span>
</span><span class='line'>
</span><span class='line'><span class="err">给</span><span class="n">contents</span><span class="err">赋</span><span class="bp">CGImage</span><span class="err">的值不是唯一的设置寄宿图的方法。我们也可以直接用</span><span class="n">Core</span> <span class="n">Graphics</span><span class="err">直接绘制寄宿图。能够通过继承</span><span class="bp">UIView</span><span class="err">并实现</span><span class="o">-</span><span class="nl">drawRect</span><span class="p">:</span><span class="err">方法来自定义绘制。</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span><span class="nl">drawRect</span><span class="p">:</span> <span class="err">方法没有默认的实现，因为对</span><span class="bp">UIView</span><span class="err">来说，寄宿图并不是必须的，它不在意那到底是单调的颜色还是有一个图片的实例。如果</span><span class="bp">UIView</span><span class="err">检测到</span><span class="o">-</span><span class="nl">drawRect</span><span class="p">:</span> <span class="err">方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以</span> <span class="n">contentsScale</span><span class="err">的值。</span>
</span><span class='line'>
</span><span class='line'><span class="err">如果你不需要寄宿图，那就不要创建这个方法了，这会造成</span><span class="n">CPU</span><span class="err">资源和内存的浪费，这也是为什么苹果建议：如果没有自定义绘制的任务就不要在子类中写一个空的</span><span class="o">-</span><span class="nl">drawRect</span><span class="p">:</span><span class="err">方法。</span>
</span><span class='line'>
</span><span class='line'><span class="err">当视图在屏幕上出现的时候</span> <span class="o">-</span><span class="nl">drawRect</span><span class="p">:</span><span class="err">方法就会被自动调用。</span><span class="o">-</span><span class="nl">drawRect</span><span class="p">:</span><span class="err">方法里面的代码利用</span><span class="n">Core</span> <span class="n">Graphics</span><span class="err">去绘制一个寄宿图，然后内容就会被缓存起来直到它需要被更新（通常是因为开发者调用了</span><span class="o">-</span><span class="n">setNeedsDisplay</span><span class="err">方法，尽管影响到表现效果的属性值被更改时，一些视图类型会被自动重绘，如</span><span class="n">bounds</span><span class="err">属性）。虽然</span><span class="o">-</span><span class="nl">drawRect</span><span class="p">:</span><span class="err">方法是一个</span><span class="bp">UIView</span><span class="err">方法，事实上都是底层的</span><span class="bp">CALayer</span><span class="err">安排了重绘工作和保存了因此产生的图片。</span>
</span><span class='line'>
</span><span class='line'><span class="bp">CALayer</span><span class="err">有一个可选的</span><span class="n">delegate</span><span class="err">属性，实现了</span><span class="n">CALayerDelegate</span><span class="err">协议，当</span><span class="bp">CALayer</span><span class="err">需要一个内容特定的信息时，就会从协议中请求。</span><span class="n">CALayerDelegate</span><span class="err">是一个非正式协议，其实就是说没有</span><span class="n">CALayerDelegate</span> <span class="p">@</span><span class="n">protocol</span><span class="err">可以让你在类里面引用啦。你只需要调用你想调用的方法，</span><span class="bp">CALayer</span><span class="err">会帮你做剩下的。（</span><span class="n">delegate</span><span class="err">属性被声明为</span><span class="kt">id</span><span class="err">类型，所有的代理方法都是可选的）。</span>
</span><span class='line'>
</span><span class='line'><span class="err">当需要被重绘时，</span><span class="bp">CALayer</span><span class="err">会请求它的代理给它一个寄宿图来显示。它通过调用下面这个方法做到的</span><span class="o">:</span>
</span></code></pre></td></tr></table></div></figure>


<p>objective-c</p>

<p>(void)displayLayer:(CALayer *)layer;</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="err">趁着这个机会，如果代理想直接设置`</span><span class="n">contents</span><span class="err">`属性的话，它就可以这么做，不然没有别的方法可以调用了。如果代理不实现`</span><span class="o">-</span><span class="nl">displayLayer</span><span class="p">:</span><span class="err">`方法，</span><span class="bp">CALayer</span><span class="err">就会转而尝试调用下面这个方法：</span>
</span></code></pre></td></tr></table></div></figure>


<p>objective-c</p>

<ul>
<li>(void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="err">在调用这个方法之前，</span><span class="bp">CALayer</span><span class="err">创建了一个合适尺寸的空寄宿图（尺寸由</span><span class="n">bounds</span><span class="err">和</span><span class="n">contentsScale</span><span class="err">决定）和一个</span><span class="n">Core</span> <span class="n">Graphics</span><span class="err">的绘制上下文环境，为绘制寄宿图做准备，它作为</span><span class="n">ctx</span><span class="err">参数传入。</span>
</span><span class='line'>
</span><span class='line'><span class="cp">###3、图层几何学</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#### 布局</span>
</span><span class='line'><span class="bp">UIView</span><span class="err">有三个比较重要的布局属性：</span><span class="n">frame</span><span class="err">，</span><span class="n">bounds</span><span class="err">和</span><span class="n">center</span><span class="err">，</span><span class="bp">CALayer</span><span class="err">对应地叫做</span><span class="n">frame</span><span class="err">，</span><span class="n">bounds</span><span class="err">和</span><span class="n">position</span><span class="err">。为了能清楚区分，图层用了“</span><span class="n">position</span><span class="err">”，视图用了“</span><span class="n">center</span><span class="err">”，但是他们都代表同样的值。</span><span class="n">frame</span><span class="err">代表了图层的外部坐标（也就是在父图层上占据的空间），</span><span class="n">bounds</span><span class="err">是内部坐标（</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span><span class="err">通常是图层的左上角），</span><span class="n">center</span><span class="err">和</span><span class="n">position</span><span class="err">都代表了相对于父图层</span><span class="o">*</span><span class="n">anchorPoint</span><span class="o">*</span><span class="err">锚点所在的位置。</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#### 锚点 anchorPoint</span>
</span><span class='line'><span class="err">视图的</span><span class="n">center</span><span class="err">属性和图层的</span><span class="n">position</span><span class="err">属性都指定了</span><span class="n">anchorPoint</span><span class="err">相对于父图层的位置。图层的</span><span class="n">anchorPoint</span><span class="err">通过</span><span class="n">position</span><span class="err">来控制它的</span><span class="n">frame</span><span class="err">的位置，你可以认为</span><span class="n">anchorPoint</span><span class="err">是用来移动图层的把柄。</span>
</span><span class='line'>
</span><span class='line'><span class="err">默认来说，</span><span class="n">anchorPoint</span><span class="err">位于图层的中点，所以图层的将会以这个点为中心放置。</span><span class="n">anchorPoint</span><span class="err">属性并没有被</span><span class="bp">UIView</span><span class="err">接口暴露出来，这也是视图的</span><span class="n">position</span><span class="err">属性被叫做“</span><span class="n">center</span><span class="err">”的原因。但是图层的</span><span class="n">anchorPoint</span><span class="err">可以被移动，比如你可以把它置于图层</span><span class="n">frame</span><span class="err">的左上角，于是图层的内容将会向右下角的</span><span class="n">position</span><span class="err">方向移动</span>
</span><span class='line'>
</span><span class='line'><span class="cp">####坐标系</span>
</span><span class='line'><span class="err">和视图一样，图层在图层树当中也是相对于父图层按层级关系放置，一个图层的`</span><span class="n">position</span><span class="err">`依赖于它父图层的`</span><span class="n">bounds</span><span class="err">`，如果父图层发生了移动，它的所有子图层也会跟着移动。</span>
</span><span class='line'>
</span><span class='line'><span class="err">这样对于放置图层会更加方便，因为你可以通过移动根图层来将它的子图层作为一个整体来移动，但是有时候你需要知道一个图层的</span><span class="o">*</span><span class="err">绝对</span><span class="o">*</span><span class="err">位置，或者是相对于另一个图层的位置，而不是它当前父图层的位置。</span>
</span><span class='line'>
</span><span class='line'><span class="err">`</span><span class="bp">CALayer</span><span class="err">`给不同坐标系之间的图层转换提供了一些工具类方法：</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">-</span> <span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nl">convertPoint</span><span class="p">:(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="n">point</span> <span class="nl">fromLayer</span><span class="p">:(</span><span class="bp">CALayer</span> <span class="o">*</span><span class="p">)</span><span class="n">layer</span><span class="p">;</span>
</span><span class='line'>    <span class="o">-</span> <span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nl">convertPoint</span><span class="p">:(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="n">point</span> <span class="nl">toLayer</span><span class="p">:(</span><span class="bp">CALayer</span> <span class="o">*</span><span class="p">)</span><span class="n">layer</span><span class="p">;</span>
</span><span class='line'>    <span class="o">-</span> <span class="p">(</span><span class="bp">CGRect</span><span class="p">)</span><span class="nl">convertRect</span><span class="p">:(</span><span class="bp">CGRect</span><span class="p">)</span><span class="n">rect</span> <span class="nl">fromLayer</span><span class="p">:(</span><span class="bp">CALayer</span> <span class="o">*</span><span class="p">)</span><span class="n">layer</span><span class="p">;</span>
</span><span class='line'>  <span class="o">-</span> <span class="p">(</span><span class="bp">CGRect</span><span class="p">)</span><span class="nl">convertRect</span><span class="p">:(</span><span class="bp">CGRect</span><span class="p">)</span><span class="n">rect</span> <span class="nl">toLayer</span><span class="p">:(</span><span class="bp">CALayer</span> <span class="o">*</span><span class="p">)</span><span class="n">layer</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="err">这些方法可以把定义在一个图层坐标系下的点或者矩形转换成另一个图层坐标系下的点或者矩形</span>
</span><span class='line'>
</span><span class='line'><span class="cp">####Z坐标轴</span>
</span><span class='line'>
</span><span class='line'><span class="err">和`</span><span class="bp">UIView</span><span class="err">`严格的二维坐标系不同，`</span><span class="bp">CALayer</span><span class="err">`存在于一个三维空间当中。除了我们已经讨论过的`</span><span class="n">position</span><span class="err">`和`</span><span class="n">anchorPoint</span><span class="err">`属性之外，`</span><span class="bp">CALayer</span><span class="err">`还有另外两个属性，`</span><span class="n">zPosition</span><span class="err">`和`</span><span class="n">anchorPointZ</span><span class="err">`，二者都是在</span><span class="n">Z</span><span class="err">轴上描述图层位置的浮点类型。</span>
</span><span class='line'>
</span><span class='line'><span class="err">注意这里并没有更</span><span class="o">*</span><span class="err">深</span><span class="o">*</span><span class="err">的属性来描述由宽和高做成的`</span><span class="n">bounds</span><span class="err">`了，图层是一个完全扁平的对象，你可以把它们想象成类似于一页二维的坚硬的纸片，用胶水粘成一个空洞，就像三维结构的折纸一样。</span>
</span><span class='line'>
</span><span class='line'><span class="err">`</span><span class="n">zPosition</span><span class="err">`属性在大多数情况下其实并不常用。在第五章，我们将会涉及`</span><span class="bp">CATransform3D</span><span class="err">`，你会知道如何在三维空间移动和旋转图层，除了做变换之外，`</span><span class="n">zPosition</span><span class="err">`最实用的功能就是改变图层的</span><span class="o">*</span><span class="err">显示顺序</span><span class="o">*</span><span class="err">了。</span>
</span><span class='line'>
</span><span class='line'><span class="err">通常，图层是根据它们子图层的`</span><span class="n">sublayers</span><span class="err">`出现的顺序来类绘制的，这就是所谓的</span><span class="o">*</span><span class="err">画家的算法</span><span class="o">*--</span><span class="err">就像一个画家在墙上作画</span><span class="o">--</span><span class="err">后被绘制上的图层将会遮盖住之前的图层，但是通过增加图层的`</span><span class="n">zPosition</span><span class="err">`，就可以把图层向相机方向</span><span class="o">*</span><span class="err">前置</span><span class="o">*</span><span class="err">，于是它就在所有其他图层的</span><span class="o">*</span><span class="err">前面</span><span class="o">*</span><span class="err">了（或者至少是小于它的`</span><span class="n">zPosition</span><span class="err">`值的图层的前面）。</span>
</span><span class='line'>
</span><span class='line'><span class="err">这里所谓的“相机”实际上是相对于用户是视角，这里和</span><span class="n">iPhone</span><span class="err">背后的内置相机没任何关系。</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#### Hit Testing</span>
</span><span class='line'><span class="bp">CALayer</span><span class="err">并不关心任何响应链事件，所以不能直接处理触摸事件或者手势。但是它有一系列的方法帮你处理事件：</span><span class="o">-</span><span class="nl">containsPoint</span><span class="p">:</span><span class="err">和</span><span class="o">-</span><span class="nl">hitTest</span><span class="p">:</span><span class="err">。</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span><span class="nl">containsPoint</span><span class="p">:</span><span class="err">接受一个在本图层坐标系下的</span><span class="bp">CGPoint</span><span class="err">，如果这个点在图层</span><span class="n">frame</span><span class="err">范围内就返回</span><span class="nb">YES</span>
</span><span class='line'>
</span><span class='line'><span class="cp">###4、视觉效果</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#### 圆角</span>
</span><span class='line'><span class="bp">CALayer</span><span class="err">有一个叫做`</span><span class="n">conrnerRadius</span><span class="err">`的属性控制着图层角的曲率。它是一个浮点数，默认为</span><span class="mi">0</span><span class="err">（为</span><span class="mi">0</span><span class="err">的时候就是直角），但是你可以把它设置成任意值。默认情况下，这个曲率值只影响背景颜色而不影响背景图片或是子图层。不过，如果把`</span><span class="n">masksToBounds</span><span class="err">`设置成</span><span class="nb">YES</span><span class="err">的话，图层里面的所有东西都会被截取。</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#### 图层边框</span>
</span><span class='line'><span class="bp">CALayer</span><span class="err">另外两个非常有用属性就是`</span><span class="n">borderWidth</span><span class="err">`和`</span><span class="n">borderColor</span><span class="err">`。二者共同定义了图层边的绘制样式。这条线（也被称作</span><span class="n">stroke</span><span class="err">）沿着图层的</span><span class="n">bounds</span><span class="err">绘制，同时也包含图层的角。</span>
</span><span class='line'>
</span><span class='line'><span class="err">`</span><span class="n">borderWidth</span><span class="err">`是以点为单位的定义边框粗细的浮点数，默认为</span><span class="mf">0.</span><span class="n">borderColor</span><span class="err">定义了边框的颜色，默认为黑色。</span>
</span><span class='line'>
</span><span class='line'><span class="err">`</span><span class="n">borderColor</span><span class="err">`是</span><span class="n">CGColorRef</span><span class="err">类型，而不是</span><span class="bp">UIColor</span><span class="err">，所以它不是</span><span class="n">Cocoa</span><span class="err">的内置对象。不过呢，你肯定也清楚图层引用了</span><span class="n">borderColor</span><span class="err">，虽然属性声明并不能证明这一点。</span><span class="n">CGColorRef</span><span class="err">在引用</span><span class="o">/</span><span class="err">释放时候的行为表现得与</span><span class="bp">NSObject</span><span class="err">极其相似。但是</span><span class="n">Objective</span><span class="o">-</span><span class="n">C</span><span class="err">语法并不支持这一做法，所以</span><span class="n">CGColorRef</span><span class="err">属性即便是强引用也只能通过</span><span class="k">assign</span><span class="err">关键字来声明</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#### 阴影</span>
</span><span class='line'><span class="n">iOS</span><span class="err">的另一个常见特性呢，就是阴影。阴影往往可以达到图层深度暗示的效果。也能够用来强调正在显示的图层和优先级（比如说一个在其他视图之前的弹出框），不过有时候他们只是单纯的装饰目的。</span>
</span><span class='line'>
</span><span class='line'><span class="err">给`</span><span class="n">shadowOpacity</span><span class="err">`属性一个大于默认值（也就是</span><span class="mi">0</span><span class="err">）的值，阴影就可以显示在任意图层之下。`</span><span class="n">shadowOpacity</span><span class="err">`是一个必须在</span><span class="mf">0.0</span><span class="err">（不可见）和</span><span class="mf">1.0</span><span class="err">（完全不透明）之间的浮点数。如果设置为</span><span class="mf">1.0</span><span class="err">，将会显示一个有轻微模糊的黑色阴影稍微在图层之上。若要改动阴影的表现，你可以使用</span><span class="bp">CALayer</span><span class="err">的另外三个属性：`</span><span class="n">shadowColor</span><span class="err">`，`</span><span class="n">shadowOffset</span><span class="err">`和`</span><span class="n">shadowRadius</span><span class="err">`。</span>
</span><span class='line'>
</span><span class='line'><span class="err">显而易见，`</span><span class="n">shadowColor</span><span class="err">`属性控制着阴影的颜色，和`</span><span class="n">borderColor</span><span class="err">`和`</span><span class="n">backgroundColor</span><span class="err">`一样，它的类型也是`</span><span class="n">CGColorRef</span><span class="err">`。阴影默认是黑色，大多数时候你需要的阴影也是黑色的（其他颜色的阴影看起来是不是有一点点奇怪。。）。</span>
</span><span class='line'>
</span><span class='line'><span class="err">`</span><span class="n">shadowOffset</span><span class="err">`属性控制着阴影的方向和距离。它是一个`</span><span class="bp">CGSize</span><span class="err">`的值，宽度控制这阴影横向的位移，高度控制着纵向的位移。`</span><span class="n">shadowOffset</span><span class="err">`的默认值是</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">}</span><span class="err">，意即阴影相对于</span><span class="n">Y</span><span class="err">轴有</span><span class="mi">3</span><span class="err">个点的向上位移。</span>
</span><span class='line'>
</span><span class='line'><span class="err">为什么要默认向上的阴影呢？尽管</span><span class="n">Core</span> <span class="n">Animation</span><span class="err">是从图层套装演变而来（可以认为是为</span><span class="n">iOS</span><span class="err">创建的私有动画框架），但是呢，它却是在</span><span class="n">Mac</span> <span class="n">OS</span><span class="err">上面世的，前面有提到，二者的</span><span class="n">Y</span><span class="err">轴是颠倒的。这就导致了默认的</span><span class="mi">3</span><span class="err">个点位移的阴影是向上的。在</span><span class="n">Mac</span><span class="err">上，`</span><span class="n">shadowOffset</span><span class="err">`的默认值是阴影向下的，这样你就能理解为什么</span><span class="n">iOS</span><span class="err">上的阴影方向是向上的了</span><span class="p">.</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#### shadowPath属性</span>
</span><span class='line'>
</span><span class='line'><span class="err">我们已经知道图层阴影并不总是方的，而是从图层内容的形状继承而来。这看上去不错，但是实时计算阴影也是一个非常消耗资源的，尤其是图层有多个子图层，每个图层还有一个有透明效果的寄宿图的时候。</span>
</span><span class='line'>
</span><span class='line'><span class="err">如果你事先知道你的阴影形状会是什么样子的，你可以通过指定一个`</span><span class="n">shadowPath</span><span class="err">`来提高性能。`</span><span class="n">shadowPath</span><span class="err">`是一个`</span><span class="n">CGPathRef</span><span class="err">`类型（一个指向`</span><span class="bp">CGPath</span><span class="err">`的指针）。`</span><span class="bp">CGPath</span><span class="err">`是一个</span><span class="n">Core</span> <span class="n">Graphics</span><span class="err">对象，用来指定任意的一个矢量图形。我们可以通过这个属性单独于图层形状之外指定阴影的形状。</span>
</span><span class='line'>
</span><span class='line'><span class="err">创建简单的阴影形状</span>
</span></code></pre></td></tr></table></div></figure>


<p> objective-c</p>

<p>@interface ViewController ()</p>

<p>@property (nonatomic, weak) IBOutlet UIView <em>layerView1;
@property (nonatomic, weak) IBOutlet UIView </em>layerView2;
@end</p>

<p>@implementation ViewController</p>

<p>-(void)viewDidLoad
{
  [super viewDidLoad];</p>

<p>  //enable layer shadows
  self.layerView1.layer.shadowOpacity = 0.5f;
  self.layerView2.layer.shadowOpacity = 0.5f;</p>

<p>  //create a square shadow
  CGMutablePathRef squarePath = CGPathCreateMutable();
  CGPathAddRect(squarePath, NULL, self.layerView1.bounds);
  self.layerView1.layer.shadowPath = squarePath;
  CGPathRelease(squarePath);</p>

<p>  ￼//create a circular shadow
  CGMutablePathRef circlePath = CGPathCreateMutable();
  CGPathAddEllipseInRect(circlePath, NULL,self.layerView2.bounds);
  self.layerView2.layer.shadowPath = circlePath; <br/>
  CGPathRelease(circlePath);
}
@end</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="err">如果是一个矩形或者是圆，用`</span><span class="bp">CGPath</span><span class="err">`会相当简单明了。但是如果是更加复杂一点的图形，`</span><span class="bp">UIBezierPath</span><span class="err">`类会更合适，它是一个由</span><span class="n">UIKit</span><span class="err">提供的在</span><span class="bp">CGPath</span><span class="err">基础上的</span><span class="n">Objective</span><span class="o">-</span><span class="n">C</span><span class="err">包装类。</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#### 图层蒙板</span>
</span><span class='line'><span class="err">通过`</span><span class="n">masksToBounds</span><span class="err">`属性，我们可以沿边界裁剪图形；通过`</span><span class="n">cornerRadius</span><span class="err">`属性，我们还可以设定一个圆角。但是有时候你希望展现的内容不是在一个矩形或圆角矩形。比如，你想展示一个有星形框架的图片，又或者想让一些古卷文字慢慢渐变成背景色，而不是一个突兀的边界。</span>
</span><span class='line'>
</span><span class='line'><span class="err">使用一个</span><span class="mi">32</span><span class="err">位有</span><span class="n">alpha</span><span class="err">通道的</span><span class="n">png</span><span class="err">图片通常是创建一个无矩形视图最方便的方法，你可以给它指定一个透明蒙板来实现。但是这个方法不能让你以编码的方式动态地生成蒙板，也不能让子图层或子视图裁剪成同样的形状。</span>
</span><span class='line'>
</span><span class='line'><span class="bp">CALayer</span><span class="err">有一个属性叫做`</span><span class="n">mask</span><span class="err">`可以解决这个问题。这个属性本身就是个</span><span class="bp">CALayer</span><span class="err">类型，有和其他图层一样的绘制和布局属性。它类似于一个子图层，相对于父图层（即拥有该属性的图层）布局，但是它却不是一个普通的子图层。不同于那些绘制在父图层中的子图层，`</span><span class="n">mask</span><span class="err">`图层定义了父图层的部分可见区域。</span>
</span><span class='line'>
</span><span class='line'><span class="err">`</span><span class="n">mask</span><span class="err">`图层的`</span><span class="n">Color</span><span class="err">`属性是无关紧要的，真正重要的是图层的轮廓。`</span><span class="n">mask</span><span class="err">`属性就像是一个饼干切割机，`</span><span class="n">mask</span><span class="err">`图层实心的部分会被保留下来，其他的则会被抛弃。</span>
</span><span class='line'>
</span><span class='line'><span class="err">如果`</span><span class="n">mask</span><span class="err">`图层比父图层要小，只有在`</span><span class="n">mask</span><span class="err">`图层里面的内容才是它关心的，除此以外的一切都会被隐藏起来。</span>
</span></code></pre></td></tr></table></div></figure>


<p>objective-c
@interface ViewController ()</p>

<p>@property (nonatomic, weak) IBOutlet UIImageView *imageView;
@end</p>

<p>@implementation ViewController</p>

<ul>
<li><p>(void)viewDidLoad
{
[super viewDidLoad];</p>

<p>//create mask layer
CALayer <em>maskLayer = [CALayer layer];
maskLayer.frame = self.layerView.bounds;
UIImage </em>maskImage = [UIImage imageNamed:@&ldquo;Cone.png&rdquo;];
maskLayer.contents = (__bridge id)maskImage.CGImage;</p>

<p>//apply mask to image layer￼
self.imageView.layer.mask = maskLayer;
}
@end</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="cp">#### 组透明</span>
</span><span class='line'><span class="bp">UIView</span><span class="err">有一个叫做`</span><span class="n">alpha</span><span class="err">`的属性来确定视图的透明度。</span><span class="bp">CALayer</span><span class="err">有一个等同的属性叫做`</span><span class="n">opacity</span><span class="err">`，这两个属性都是影响子层级的。也就是说，如果你给一个图层设置了`</span><span class="n">opacity</span><span class="err">`属性，那它的子图层都会受此影响。</span>
</span><span class='line'>
</span><span class='line'><span class="cp">###5、专用图层</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#### CAShapeLayer</span>
</span><span class='line'><span class="bp">CAShapeLayer</span><span class="err">是一个通过矢量图形而不是</span><span class="n">bitmap</span><span class="err">来绘制的图层子类。你指定诸如颜色和线宽等属性，用</span><span class="bp">CGPath</span><span class="err">来定义想要绘制的图形，最后</span><span class="bp">CAShapeLayer</span><span class="err">就自动渲染出来了。当然，你也可以用</span><span class="n">Core</span> <span class="n">Graphics</span><span class="err">直接向原始的</span><span class="n">CALyer</span><span class="err">的内容中绘制一个路径，相比直下，使用</span><span class="bp">CAShapeLayer</span><span class="err">有以下一些优点：</span>
</span><span class='line'>
</span><span class='line'><span class="o">+</span> <span class="err">渲染快速。</span><span class="bp">CAShapeLayer</span><span class="err">使用了硬件加速，绘制同一图形会比用</span><span class="n">Core</span> <span class="n">Graphics</span><span class="err">快很多。</span>
</span><span class='line'><span class="o">+</span> <span class="err">高效使用内存。一个</span><span class="bp">CAShapeLayer</span><span class="err">不需要像普通</span><span class="bp">CALayer</span><span class="err">一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。</span>
</span><span class='line'><span class="o">+</span> <span class="err">不会被图层边界剪裁掉。一个</span><span class="bp">CAShapeLayer</span><span class="err">可以在边界之外绘制。你的图层路径不会像在使用</span><span class="n">Core</span> <span class="n">Graphics</span><span class="err">的普通</span><span class="bp">CALayer</span><span class="err">一样被剪裁掉（如我们在第二章所见）。</span>
</span><span class='line'><span class="o">+</span> <span class="err">不会出现像素化。当你给</span><span class="bp">CAShapeLayer</span><span class="err">做</span><span class="mi">3</span><span class="n">D</span><span class="err">变换时，它不像一个有寄宿图的普通图层一样变得像素化。</span>
</span><span class='line'>
</span><span class='line'><span class="cp">###6、隐式动画</span>
</span><span class='line'><span class="n">Core</span> <span class="n">Animation</span><span class="err">基于一个假设，说屏幕上的任何东西都可以（或者可能）做动画。动画并不需要你在</span><span class="n">Core</span> <span class="n">Animation</span><span class="err">中手动打开，相反需要明确地关闭，否则他会一直存在。</span>
</span><span class='line'>
</span><span class='line'><span class="err">当你改变</span><span class="bp">CALayer</span><span class="err">的一个可做动画的属性，它并不能立刻在屏幕上体现出来。相反，它是从先前的值平滑过渡到新的值。这一切都是默认的行为，你不需要做额外的操作。</span>
</span><span class='line'>
</span><span class='line'><span class="err">这看起来这太棒了，似乎不太真实</span><span class="p">,</span><span class="err">所谓的</span><span class="o">*</span><span class="err">隐式</span><span class="o">*</span><span class="err">动画。之所以叫隐式是因为我们并没有指定任何动画的类型。我们仅仅改变了一个属性，然后</span><span class="n">Core</span> <span class="n">Animation</span><span class="err">来决定如何并且何时去做动画。</span><span class="n">Core</span> <span class="n">Animaiton</span><span class="err">同样支持</span><span class="o">*</span><span class="err">显式</span><span class="o">*</span><span class="err">动画，下章详细说明。</span>
</span><span class='line'>
</span><span class='line'><span class="err">但当你改变一个属性，</span><span class="n">Core</span> <span class="n">Animation</span><span class="err">是如何判断动画类型和持续时间的呢？实际上动画执行的时间取决于当前</span><span class="o">*</span><span class="err">事务</span><span class="o">*</span><span class="err">的设置，动画类型取决于</span><span class="o">*</span><span class="err">图层行为</span><span class="o">*</span><span class="err">。</span>
</span><span class='line'>
</span><span class='line'><span class="err">事务实际上是</span><span class="n">Core</span> <span class="n">Animation</span><span class="err">用来包含一系列属性动画集合的机制，任何用指定事务去改变可以做动画的图层属性都不会立刻发生变化，而是当事务一旦</span><span class="o">*</span><span class="err">提交</span><span class="o">*</span><span class="err">的时候开始用一个动画过渡到新值。</span>
</span><span class='line'>
</span><span class='line'><span class="err">事务是通过`</span><span class="bp">CATransaction</span><span class="err">`类来做管理，这个类的设计有些奇怪，不像你从它的命名预期的那样去管理一个简单的事务，而是管理了一叠你不能访问的事务。`</span><span class="bp">CATransaction</span><span class="err">`没有属性或者实例方法，并且也不能用`</span><span class="o">+</span><span class="n">alloc</span><span class="err">`和`</span><span class="o">-</span><span class="n">init</span><span class="err">`方法创建它。但是可以用`</span><span class="o">+</span><span class="n">begin</span><span class="err">`和`</span><span class="o">+</span><span class="n">commit</span><span class="err">`分别来入栈或者出栈。</span>
</span><span class='line'>
</span><span class='line'><span class="err">任何可以做动画的图层属性都会被添加到栈顶的事务，你可以通过`</span><span class="o">+</span><span class="nl">setAnimationDuration</span><span class="p">:</span><span class="err">`方法设置当前事务的动画时间，或者通过`</span><span class="o">+</span><span class="n">animationDuration</span><span class="err">`方法来获取值（默认</span><span class="mf">0.25</span><span class="err">秒）。</span>
</span><span class='line'>
</span><span class='line'><span class="n">Core</span> <span class="n">Animation</span><span class="err">在每个</span><span class="o">*</span><span class="n">run</span> <span class="n">loop</span><span class="o">*</span><span class="err">周期中自动开始一次新的事务（</span><span class="n">run</span> <span class="n">loop</span><span class="err">是</span><span class="n">iOS</span><span class="err">负责收集用户输入，处理定时器或者网络事件并且重新绘制屏幕的东西），即使你不显式的用`</span><span class="p">[</span><span class="bp">CATransaction</span> <span class="n">begin</span><span class="p">]</span><span class="err">`开始一次事务，任何在一次</span><span class="n">run</span> <span class="n">loop</span><span class="err">循环中属性的改变都会被集中起来，然后做一次</span><span class="mf">0.25</span><span class="err">秒的动画。</span>
</span><span class='line'>
</span><span class='line'><span class="err">明白这些之后，我们就可以轻松修改变色动画的时间了。我们当然可以用当前事务的`</span><span class="o">+</span><span class="nl">setAnimationDuration</span><span class="p">:</span><span class="err">`方法来修改动画时间，但在这里我们首先起一个新的事务，于是修改时间就不会有别的副作用。因为修改当前事务的时间可能会导致同一时刻别的动画（如屏幕旋转），所以最好还是在调整动画之前压入一个新的事务。</span>
</span><span class='line'>
</span><span class='line'><span class="err">试想一下，如果`</span><span class="bp">UIView</span><span class="err">`的属性都有动画特性的话，那么无论在什么时候修改它，我们都应该能注意到的。所以，如果说</span><span class="n">UIKit</span><span class="err">建立在</span><span class="n">Core</span> <span class="n">Animation</span><span class="err">（默认对所有东西都做动画）之上，那么隐式动画是如何被</span><span class="n">UIKit</span><span class="err">禁用掉呢？</span>
</span><span class='line'>
</span><span class='line'><span class="err">我们知道</span><span class="n">Core</span> <span class="n">Animation</span><span class="err">通常对`</span><span class="bp">CALayer</span><span class="err">`的所有属性（可动画的属性）做动画，但是`</span><span class="bp">UIView</span><span class="err">`把它关联的图层的这个特性关闭了。为了更好说明这一点，我们需要知道隐式动画是如何实现的。</span>
</span><span class='line'>
</span><span class='line'><span class="err">我们把改变属性时`</span><span class="bp">CALayer</span><span class="err">`自动应用的动画称作</span><span class="o">*</span><span class="err">行为</span><span class="o">*</span><span class="err">，当`</span><span class="bp">CALayer</span><span class="err">`的属性被修改时候，它会调用`</span><span class="o">-</span><span class="nl">actionForKey</span><span class="p">:</span><span class="err">`方法，传递属性的名称。剩下的操作都在`</span><span class="bp">CALayer</span><span class="err">`的头文件中有详细的说明，实质上是如下几步：</span>
</span><span class='line'>
</span><span class='line'><span class="o">*</span> <span class="err">图层首先检测它是否有委托，并且是否实现`</span><span class="n">CALayerDelegate</span><span class="err">`协议指定的`</span><span class="o">-</span><span class="nl">actionForLayer</span><span class="p">:</span><span class="n">forKey</span><span class="err">`方法。如果有，直接调用并返回结果。</span>
</span><span class='line'><span class="o">*</span> <span class="err">如果没有委托，或者委托没有实现`</span><span class="o">-</span><span class="nl">actionForLayer</span><span class="p">:</span><span class="n">forKey</span><span class="err">`方法，图层接着检查包含属性名称对应行为映射的`</span><span class="n">actions</span><span class="err">`字典。</span>
</span><span class='line'><span class="o">*</span> <span class="err">如果`</span><span class="n">actions</span><span class="err">字典`没有包含对应的属性，那么图层接着在它的`</span><span class="n">style</span><span class="err">`字典接着搜索属性名。</span>
</span><span class='line'><span class="o">*</span> <span class="err">最后，如果在`</span><span class="n">style</span><span class="err">`里面也找不到对应的行为，那么图层将会直接调用定义了每个属性的标准行为的`</span><span class="o">-</span><span class="nl">defaultActionForKey</span><span class="p">:</span><span class="err">`方法。</span>
</span><span class='line'>
</span><span class='line'><span class="err">所以一轮完整的搜索结束之后，`</span><span class="o">-</span><span class="nl">actionForKey</span><span class="p">:</span><span class="err">`要么返回空（这种情况下将不会有动画发生），要么是`</span><span class="bp">CAAction</span><span class="err">`协议对应的对象，最后`</span><span class="bp">CALayer</span><span class="err">`拿这个结果去对先前和当前的值做动画。</span>
</span><span class='line'>
</span><span class='line'><span class="err">于是这就解释了</span><span class="n">UIKit</span><span class="err">是如何禁用隐式动画的：每个`</span><span class="bp">UIView</span><span class="err">`对它关联的图层都扮演了一个委托，并且提供了`</span><span class="o">-</span><span class="nl">actionForLayer</span><span class="p">:</span><span class="n">forKey</span><span class="err">`的实现方法。当不在一个动画块的实现中，`</span><span class="bp">UIView</span><span class="err">`对所有图层行为返回`</span><span class="nb">nil</span><span class="err">`，但是在动画</span><span class="n">block</span><span class="err">范围之内，它就返回了一个非空值。我们可以用一个</span><span class="n">demo</span><span class="err">做个简单的实验（清单</span><span class="mf">7.5</span><span class="err">）</span>
</span><span class='line'>
</span><span class='line'><span class="err">清单</span><span class="mf">7.5</span> <span class="err">测试</span><span class="bp">UIView</span><span class="err">的`</span><span class="nl">actionForLayer</span><span class="p">:</span><span class="nl">forKey</span><span class="p">:</span><span class="err">`实现</span>
</span></code></pre></td></tr></table></div></figure>


<p>objective-c
@interface ViewController ()</p>

<p>@property (nonatomic, weak) IBOutlet UIView *layerView;</p>

<p>@end</p>

<p>@implementation ViewController</p>

<ul>
<li>(void)viewDidLoad
{
  [super viewDidLoad];
  //test layer action when outside of animation block
  NSLog(@&ldquo;Outside: %@&rdquo;, [self.layerView actionForLayer:self.layerView.layer forKey:@&ldquo;backgroundColor&rdquo;]);
  //begin animation block
  [UIView beginAnimations:nil context:nil];
  //test layer action when inside of animation block
  NSLog(@&ldquo;Inside: %@&rdquo;, [self.layerView actionForLayer:self.layerView.layer forKey:@&ldquo;backgroundColor&rdquo;]);
  //end animation block
  [UIView commitAnimations];
}</li>
</ul>


<p>@end</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="err">运行程序，控制台显示结果如下：</span>
</span><span class='line'>
</span><span class='line'>    <span class="err">$</span> <span class="n">LayerTest</span><span class="p">[</span><span class="mi">21215</span><span class="o">:</span><span class="n">c07</span><span class="p">]</span> <span class="nl">Outside</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">null</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="err">$</span> <span class="n">LayerTest</span><span class="p">[</span><span class="mi">21215</span><span class="o">:</span><span class="n">c07</span><span class="p">]</span> <span class="nl">Inside</span><span class="p">:</span> <span class="o">&lt;</span><span class="nl">CABasicAnimation</span><span class="p">:</span> <span class="mh">0x757f090</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="err">于是我们可以预言，当属性在动画块之外发生改变，`</span><span class="bp">UIView</span><span class="err">`直接通过返回`</span><span class="nb">nil</span><span class="err">`来禁用隐式动画。但如果在动画块范围之内，根据动画具体类型返回相应的属性，在这个例子就是`</span><span class="bp">CABasicAnimation</span><span class="err">`（第八章“显式动画”将会提到）。</span>
</span><span class='line'>
</span><span class='line'><span class="err">当然返回`</span><span class="nb">nil</span><span class="err">`并不是禁用隐式动画唯一的办法，`</span><span class="bp">CATransaction</span><span class="err">`有个方法叫做`</span><span class="o">+</span><span class="nl">setDisableActions</span><span class="p">:</span><span class="err">`，可以用来对所有属性打开或者关闭隐式动画。如果在清单</span><span class="mf">7.2</span><span class="err">的`</span><span class="p">[</span><span class="bp">CATransaction</span> <span class="n">begin</span><span class="p">]</span><span class="err">`之后添加下面的代码，同样也会阻止动画的发生：</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="bp">CATransaction</span> <span class="nl">setDisableActions</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="err">总结一下，我们知道了如下几点</span>
</span><span class='line'>
</span><span class='line'><span class="o">*</span> <span class="err">`</span><span class="bp">UIView</span><span class="err">`关联的图层禁用了隐式动画，对这种图层做动画的唯一办法就是使用`</span><span class="bp">UIView</span><span class="err">`的动画函数（而不是依赖`</span><span class="bp">CATransaction</span><span class="err">`），或者继承`</span><span class="bp">UIView</span><span class="err">`，并覆盖`</span><span class="o">-</span><span class="nl">actionForLayer</span><span class="p">:</span><span class="nl">forKey</span><span class="p">:</span><span class="err">`方法，或者直接创建一个显式动画（具体细节见第八章）。</span>
</span><span class='line'><span class="o">*</span> <span class="err">对于单独存在的图层，我们可以通过实现图层的`</span><span class="o">-</span><span class="nl">actionForLayer</span><span class="p">:</span><span class="nl">forKey</span><span class="p">:</span><span class="err">`委托方法，或者提供一个`</span><span class="n">actions</span><span class="err">`字典来控制隐式动画。</span>
</span><span class='line'>
</span><span class='line'><span class="err">我们来对颜色渐变的例子使用一个不同的行为，通过给`</span><span class="n">colorLayer</span><span class="err">`设置一个自定义的`</span><span class="n">actions</span><span class="err">`字典。我们也可以使用委托来实现，但是`</span><span class="n">actions</span><span class="err">`字典可以写更少的代码。那么到底改如何创建一个合适的行为对象呢？</span>
</span><span class='line'>
</span><span class='line'><span class="err">行为通常是一个被</span><span class="n">Core</span> <span class="n">Animation</span><span class="o">*</span><span class="err">隐式</span><span class="o">*</span><span class="err">调用的</span><span class="o">*</span><span class="err">显式</span><span class="o">*</span><span class="err">动画对象。这里我们使用的是一个实现了`</span><span class="bp">CATransaction</span><span class="err">`的实例，叫做</span><span class="o">*</span><span class="err">推进过渡</span><span class="o">*</span><span class="err">。</span>
</span><span class='line'>
</span><span class='line'><span class="err">第八章中将会详细解释过渡，不过对于现在，知道`</span><span class="bp">CATransition</span><span class="err">`响应`</span><span class="bp">CAAction</span><span class="err">`协议，并且可以当做一个图层行为就足够了。结果很赞，不论在什么时候改变背景颜色，新的色块都是从左侧滑入，而不是默认的渐变效果。</span>
</span><span class='line'>
</span><span class='line'><span class="err">清单</span><span class="mf">7.6</span> <span class="err">实现自定义行为</span>
</span></code></pre></td></tr></table></div></figure>


<p>objective-c
@interface ViewController ()</p>

<p>@property (nonatomic, weak) IBOutlet UIView <em>layerView;
@property (nonatomic, weak) IBOutlet CALayer </em>colorLayer;</p>

<p>@end</p>

<p>@implementation ViewController</p>

<ul>
<li><p>(void)viewDidLoad
{
  [super viewDidLoad];</p>

<p>  //create sublayer
  self.colorLayer = [CALayer layer];
  self.colorLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);
  self.colorLayer.backgroundColor = [UIColor blueColor].CGColor;
  //add a custom action
  CATransition *transition = [CATransition animation];
  transition.type = kCATransitionPush;
  transition.subtype = kCATransitionFromLeft;
  self.colorLayer.actions = @{@&ldquo;backgroundColor&rdquo;: transition};
  //add it to our view
  [self.layerView.layer addSublayer:self.colorLayer];
}</p></li>
<li><p>(IBAction)changeColor
{
  //randomize the layer background color
  CGFloat red = arc4random() / (CGFloat)INT_MAX;
  CGFloat green = arc4random() / (CGFloat)INT_MAX;
  CGFloat blue = arc4random() / (CGFloat)INT_MAX;
  self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;
}</p></li>
</ul>


<p>@end
&#8220;`</p>

<h3>7、显式动画</h3>

<p>属性动画作用于图层的某个单一属性，并指定了它的一个目标值，或者一连串将要做动画的值。属性动画分为两种：<em>基础</em>和<em>关键帧</em>。</p>

<p><em>基础</em>：动画其实就是一段时间内发生的改变，最简单的形式就是从一个值改变到另一个值，这也是<code>CABasicAnimation</code>最主要的功能</p>

<p><em>关键帧</em>：<code>CABasicAnimation</code>揭示了大多数隐式动画背后依赖的机制，这的确很有趣，但是显式地给图层添加<code>CABasicAnimation</code>相较于隐式动画而言，只能说费力不讨好。</p>

<p><code>CAKeyframeAnimation</code>是另一种UIKit没有暴露出来但功能强大的类。和<code>CABasicAnimation</code>类似，<code>CAKeyframeAnimation</code>同样是<code>CAPropertyAnimation</code>的一个子类，它依然作用于单一的一个属性，但是和<code>CABasicAnimation</code>不一样的是，它不限制于设置一个起始和结束的值，而是可以根据一连串随意的值来做动画。</p>

<p><em>关键帧</em>起源于传动动画，意思是指主导的动画在显著改变发生时重绘当前帧（也就是<em>关键</em>帧），每帧之间剩下的绘制（可以通过关键帧推算出）将由熟练的艺术家来完成。<code>CAKeyframeAnimation</code>也是同样的道理：你提供了显著的帧，然后Core Animation在每帧之间进行插入。</p>

<h3>8、缓冲</h3>

<h3><code>CAMediaTimingFunction</code></h3>

<p>那么该如何使用缓冲方程式呢？首先需要设置<code>CAAnimation</code>的<code>timingFunction</code>属性，是<code>CAMediaTimingFunction</code>类的一个对象。如果想改变隐式动画的计时函数，同样也可以使用<code>CATransaction</code>的<code>+setAnimationTimingFunction:</code>方法。</p>

<p>这里有一些方式来创建<code>CAMediaTimingFunction</code>，最简单的方式是调用<code>+timingFunctionWithName:</code>的构造方法。这里传入如下几个常量之一：</p>

<pre><code>kCAMediaTimingFunctionLinear 
kCAMediaTimingFunctionEaseIn 
kCAMediaTimingFunctionEaseOut 
kCAMediaTimingFunctionEaseInEaseOut
kCAMediaTimingFunctionDefault
</code></pre>

<p><code>kCAMediaTimingFunctionLinear</code>选项创建了一个线性的计时函数，同样也是<code>CAAnimation</code>的<code>timingFunction</code>属性为空时候的默认函数。线性步调对于那些立即加速并且保持匀速到达终点的场景会有意义（例如射出枪膛的子弹），但是默认来说它看起来很奇怪，因为对大多数的动画来说确实很少用到。</p>

<p><code>kCAMediaTimingFunctionEaseIn</code>常量创建了一个慢慢加速然后突然停止的方法。对于之前提到的自由落体的例子来说很适合，或者比如对准一个目标的导弹的发射。</p>

<p><code>kCAMediaTimingFunctionEaseOut</code>则恰恰相反，它以一个全速开始，然后慢慢减速停止。它有一个削弱的效果，应用的场景比如一扇门慢慢地关上，而不是砰地一声。</p>

<p><code>kCAMediaTimingFunctionEaseInEaseOut</code>创建了一个慢慢加速然后再慢慢减速的过程。这是现实世界大多数物体移动的方式，也是大多数动画来说最好的选择。如果只可以用一种缓冲函数的话，那就必须是它了。那么你会疑惑为什么这不是默认的选择，实际上当使用<code>UIView</code>的动画方法时，他的确是默认的，但当创建<code>CAAnimation</code>的时候，就需要手动设置它了。</p>

<p>最后还有一个<code>kCAMediaTimingFunctionDefault</code>，它和<code>kCAMediaTimingFunctionEaseInEaseOut</code>很类似，但是加速和减速的过程都稍微有些慢。它和<code>kCAMediaTimingFunctionEaseInEaseOut</code>的区别很难察觉，可能是苹果觉得它对于隐式动画来说更适合（然后对UIKit就改变了想法，而是使用<code>kCAMediaTimingFunctionEaseInEaseOut</code>作为默认效果），虽然它的名字说是默认的，但还是要记住当创建<em>显式</em>的<code>CAAnimation</code>它并不是默认选项（换句话说，默认的图层行为动画用<code>kCAMediaTimingFunctionDefault</code>作为它们的计时方法）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS9  Universal Links （通用链接）]]></title>
    <link href="http://strivingboy.github.io/blog/2015/09/27/ios9/"/>
    <updated>2015-09-27T15:07:13+08:00</updated>
    <id>http://strivingboy.github.io/blog/2015/09/27/ios9</id>
    <content type="html"><![CDATA[<p><strong>&ldquo;What is Universal Links?&rdquo;</strong></p>

<p>Apple 推出通用链接：一种能够方便的通过传统 HTTP 链接来启动 APP, 使用相同的网址打开网站和 APP。</p>

<p>通过唯一的网址, 不需要特别的schema就可以链接一个特定的视图到APP 里面  。比如：在微信中使用了通用链接, 那么用户在Safari、UIWebView或者 WKWebView点击一个链接, iOS设备上的微信app怎会在微信里面自动打开这个页面, 如果没有安装则在Safrai中打开响应链接。</p>

<blockquote><p>NOTE:
Universal links let iOS 9 users open your app when they tap links to your website within WKWebView and UIWebView views and Safari pages, in addition to links that result in a call to openURL:, such as those that occur in Mail, Messages, and other apps.</p></blockquote>

<p>For users who are running versions of iOS earlier than 9.0, tapping a universal link to your website opens the link in Safari.</p>

<!--more-->


<p><strong>&ldquo;How to support Universal Links?&rdquo;</strong></p>

<ul>
<li><p>Step1:创建一个json 格式的apple-app-site-associatio 文件如下：</p>

<pre><code class="`` ">  {
      "applinks": {
          "apps": [],
          "details": [
              {
                  "appID": "9JA89QQLNQ.com.apple.wwdc",
                  "paths": [ "/wwdc/news/", "/videos/wwdc/2015/*" ]
              },
              {
                  "appID": "TeamID.BundleID2",
                  "paths": [ "*" ]
              }
          ]
      }
  }
</code></pre>

<p>  根据 paths 键设定允许的路径列表, 或只是一个星号如果你想打开 APP 而不管路径是 什么</p>

<p>  注意：paths 路径是大小写敏感的</p>

<blockquote><p>NOTE:The website paths you specify in the paths array are case sensitive.”</p></blockquote>

<p>  &ldquo;appID&#8221;组成部分：TeamID + BundleId TeamID可以从苹果开发账号页面也“Your   Account”下查看，BundleId就直接在工程里看了</p></li>
<li><p>Step2:上传 apple-app-site-association 文件</p>

<p>  注意：</p>

<p>  1、上传到web server根目录下</p>

<p>  2、web server 需要支持https,客户端需要通告https访问，并且不支持任何重定向</p>

<blockquote><p>upload it to the root of your HTTPS web server. The file needs to be accessible via HTTPS—without any redirects—at <a href="https://">https://</a><domain>/apple-app-site-association. Next, you need to handle universal links in your app.</p></blockquote></li>
<li><p>Step3:在 APP 里处理通用链接</p>

<ul>
<li><p>1、添加域名到 Capabilities</p>

<p>  在 Xcode 的 capabilities 里 添加你的 APP 域名, 必须用 applinks: 前置它   <img src="http://strivingboy.github.io/images/domain.png" alt="" />
  这将使APP从上门的域名请求Step2中创建的JSON 文件 apple-app-site-association。当你第一次启动 APP，它会从 <a href="https://domain.com/apple-app-site-association">https://domain.com/apple-app-site-association</a> 下载这个文件。</p></li>
<li><p>2、在 AppDelegate 里支持通用链接</p></li>
</ul>


<p>  实现：
   <code>- (BOOL)application:(UIApplication *)application
   continueUserActivity:(NSUserActivity *)userActivity
     restorationHandler:(void (^)(NSArray *restorableObjects))restorationHandler</code>方法，如下：</p>

<p>  <img src="http://strivingboy.github.io/images/delegate.png" alt="" /></p>

<p>  当 userActivity 是 NSUserActivityTypeBrowsingWeb 类型, 则意味着它已经由通用链接 API 代理。这样的话, 它保证用户打开的 URL 将有一个非空的 webpageURL 属性</p></li>
</ul>


<p><strong> apple 官网地址 </strong></p>

<p><a href="https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12-SW2">通用链接 Universal Links</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS9 新特性介绍]]></title>
    <link href="http://strivingboy.github.io/blog/2015/07/19/ios9/"/>
    <updated>2015-07-19T15:07:13+08:00</updated>
    <id>http://strivingboy.github.io/blog/2015/07/19/ios9</id>
    <content type="html"><![CDATA[<p>本文翻译 <a href="https://www.shinobicontrols.com/blog/ios9-day-by-day-index">iOS9 Day-by-Day</a> 中对iOS9新特性简单介绍下</p>

<ul>
<li><p><strong>三种搜索API</strong></p>

<p>  <strong>NSUserActivity:</strong>
  NSUserActivity是iOS 8专为Handoff推出的API，iOS 9之后得到了提升。现在用户只需提供元数据（metadata）就能搜索不同的activity（活动）了。换言之，Spotlight可以将activity编入索引，而NSUserActivity就好比网页浏览器的历史堆栈（history stack），使用户能在Spotlight上搜到最近的活动。</p>

<p>  <strong>Web Markup:</strong>
  Web Markup在网页上显示App的内容并编入Spotlight索引，如此一来即便没有安装某个App，苹果的索引器也能在网页上搜索特别的标记（markup），在Safari或Spotlight上显示搜索结果。
显示未安装App的搜索结果是一大亮点，有望为开发者带来更多潜在用户。公布在搜索API上的App深链接则储存在苹果的cloud index中。更多详情，请参阅苹果的（<a href="https://developer.apple.com/library/prerelease/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS9.html#//apple_ref/doc/uid/TP40016198-SW4">Web Markup使用指南</a>）”。</p>

<p>  <strong>CoreSpotlight:</strong>
  NSUserActivity帮助储存用户历史，而全新的Core Spotlight则能将App中的任何内容编入索引，实质是在用户设备上提供基础的Core Spotlight索引渠道，满足用户另外一个需求。</p></li>
</ul>


<!--more-->


<ul>
<li><p><strong>UI Testing</strong></p>

<p>  在Xcode7中，苹果介绍了一种新的方式来管理你的应用界面的测试工作。UI testing 允许你对 UI 元素进行查找，交互，验证属性和状态。在 Xcode7 中，UI testing 伴随着测试报告，并且和单元测试一起运行。 XCTest 是在 Xcode 5 时融入到测试框架的，在Xcode7 中，新增了对 UI 的测试能力。允许在特定点设置断言，查看UI当时的状态。</p>

<p>  <strong>Accessibility（辅助功能）:</strong>
  为了 UI Testing 能够工作，框架需要和你的众多元素直接建立连接，然后安排好操作。你可以设定义特别的点，或者在某个 UI 上创建 tweak，然后指定点击或者滑动操作。但是这在不同尺寸设备上就失效了。这时候 accessibility，就能提供帮助了。Accessibility 是苹果自家发布的一个框架，它可以自动记录你的操作流程，允许用户进行丰富的操作。你可以（也应该）让你的元素具备Accessibility的能力。有很多原因，比如说自定义的控件，不能够被自动发现。
UI Testing 有能力通过你的应用提供给 Accessibility 的特性，来对不同尺寸的设备进行测试提供解决方案。也保证了你在重新组织了一下你的 UI 之后，不必全部重新写一套测试。不仅能够帮助你测试自己的 UI，同时也能够对你的应用，更好的支持有一定身体障碍的人群使用而带来帮助。</p>

<p>  <strong>UI 录制 :</strong>一旦你设置好了你的 accessible UI,你将要创建 UI 的测试项。编写 UI 的测试是非常耗时，无聊的，如果你的 UI 比较复杂，也是非常困难的。感谢 Xcode7, 苹果介绍了 UI Recording. 他允许你新建、或者在已有项目中创建测试。当你打开时，测试代码会随着你在设备或模拟器上操作自动创建。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读《如何把事情做的最好》]]></title>
    <link href="http://strivingboy.github.io/blog/2015/07/12/dobetter/"/>
    <updated>2015-07-12T10:38:11+08:00</updated>
    <id>http://strivingboy.github.io/blog/2015/07/12/dobetter</id>
    <content type="html"><![CDATA[<p>最近阅读了《如何把事情做的最好》这本书，在此写下读书笔记，这也是第一次写读书笔记，给自己一个坚持读书的动力哈哈。</p>

<p>开篇：
每个人生来都具备足够的潜力，每个人都能做到别人眼中难以企及的事情。请永远保持初学之心，勇敢面对人生挑战。
追求速成的浮躁气氛是当下社会的顽疾，若不加以重视，它将带来毁灭性的的后果。只有通过长期的努力，走上精益求精之路，坚持不追求短期目标的持续练习，才能把事情做到最好，最终获得成功。</p>

<h3>Tips1: 怎样才能把事情做到最好?</h3>

<p>   学习任何事情都要通过多次的练习和模仿，经过几个漫长的平台期，在量变引起质变之前，会有很长一段时间感到迷茫，并且进步缓慢。一旦你突破了平台期，学会的技能将伴随你一生，随着学习的深入和练习的深入，你渐渐觉得不那么困难了，并且乐在其中，最后成为一种本能。如何把事情做好，就像你学习抬手触摸额头一样，你同样可以学会英语、算法、编程，还可以学会更好的与别人交往，学会更好的工作和生活。有心之人任何时候都可以踏上精益求精之旅。</p>

<!--more-->


<h3>Tips2: 化难为易的精益求精之道</h3>

<p>坚持将事情做到极致。现在社会中大多数人都处于平台期，这种感觉是十分煎熬的。它让你感到挫败，不仅如此，还会慢慢的消耗你的进取心。这个练习的过程是无法跳过的，需要一点一滴的积累，成功没有捷径，你要将学习变成一种习惯。学习任何新的东西，都会首先经历一段快速成长期，随后回落到平台期。想要获得成功，需要艰苦的训练，不断磨练技艺，精益求精，循序渐进。</p>

<h3>Tips3: 认清自己：你属于哪种类型的人</h3>

<ul>
<li><p>浅尝辄止者</p>

<p>  浅尝辄止者对一切新东西充满好奇,一旦尝到学习曲线中最开始的那段快速成长期的甜头，就会被喜悦冲昏头脑,之后进入平台期是他们之前没有想到的，更是难以忍受。</p></li>
<li><p>强求突破者</p>

<p>  强求突破者往往具有坚定的性格，他们奋勇争先，从不安于第二名。他们重视结果，不管付出什么代价都要完成预定目标。但是当他们真正身处平台期的时候，那种毫无进步的感觉令他们无法忍受。他们开始质疑自己，盲目付出努力，他们对同事和亲朋好友的种种忠告和建议根本听不进去。总之，不论做什么事，强求突破者总是永不停歇的追求进步，然而又无法避免上升曲线过后的那段曲折回落。</p></li>
<li><p>安于现状者</p>

<p>  安于现状者的表现又是另一种样子，最初的进步之后，他们可能甘愿一直停在平台期。只要不耽误事，他们就无所谓进步，无所谓精益求精。</p></li>
</ul>


<h3>Tips4: 一份耕耘才能一份收获</h3>

<p>当你决定踏上精益求精之路时，你会突然发现周围的一切都与你所追求的格格不入。我们必须直视潜在的危机，坚持长期稳定的进步，发扬踏实向上的作风，摒弃不劳而获的思想。在精益求精的道路上我们任重而道远。</p>

<h3>Tips5: 热爱平台期</h3>

<p>一个人在精益求精之路上稳步前进，想要生活过的充实而幸福，那么首先要习惯平台期。如果做不到那么他将会在平台期无比纠结，并且心浮气躁的想要尽快摆脱这恼人的阶段，心浮气躁的他怎么能得到幸福呢？热爱平台期，才能充分享受进步的快感，才能坦然面对下一个平台期。热爱平台期，就是对平凡生活的热爱。</p>

<h3>Tips6: 把事情做好的5大要素</h3>

<ul>
<li><p>有效的指导</p>

<p>  找一位好导师学习基础知识，刻苦远比天分重要，请时刻记住，成功之路没有终点。正如日本剑道大师所说“求学之患，在于自满；为师之道，永无止境”.</p></li>
<li><p>持续练习</p>

<p>  练习不是简单的重复，对于那些追求精益求精境界的人来说, 他们不应仅仅把 练习看成一遍遍重复的动作，更不应把练习当成是简单的活动，而是要把练习和自身 融合起来,让它成为自己生活中必不可少的要素。这就是古老的东方文明所宣扬的“道”。你努力练习,练习就会造就你。可以说精益求精的成功之路就是练习铺就而成的.</p></li>
<li><p>保持初学的心态</p>

<p>  <strong>重复的力量:</strong> 伴随整个学习过程的是一遍又一遍的重复，越是基础的部分重复的次数越多。</p>

<p>  <strong>舍得放弃:</strong> 懂得改变在学习的不同阶段，随时都要保持归零的心态，以迎接不同阶段的挑战，越是自己熟悉的东西、熟悉的领域，这个挑战越艰巨。就像你在手中端着一杯牛奶，远处的桌上有一整瓶，如果舍不得放下手中的这一杯，就无法得到桌上的那一瓶。</p>

<p>  <strong>人人都是初学者:</strong> 时刻保持平和的心态，把自己看做新手或许是成功之路上最重要的——无论是追求事业成功，还是家庭和睦，无论是学打羽毛球，还是学习跳芭蕾都要如此。真正的成功者会时刻保持归零的心态。在这条求索之路上，人人都是初学者</p></li>
<li><p>胸有成竹</p>

<p>  大胆的想象自己希望的结果，开始之前先想象一个美好的愿景，然后为这个愿景去奋斗。就像我练习健美的时候，不止一次地想象自己获得宇宙先生之后的样子。”胸有成竹的从容，将一直存在于真正的成功者心中。</p></li>
<li><p>超越极限</p>

<p>  经验来自千百次的实践，学习是一场无止境的旅程，要有愚者精神，挑战极限是一门平衡的艺术，需要不断的将自己推向崩溃的边缘。当然，在你下决心做出挑战极限的行动之前，要确保自己已经经过刻苦训练并胸有成竹。然后，尽管去挑战极限吧。</p></li>
</ul>


<h3>Tips7: 把事情做到最好的高效方法</h3>

<ul>
<li>当你感到退步时，请挺住！</li>
<li>对旧有习惯时刻保持警惕</li>
<li>养成规律练习的好习惯</li>
<li>终生学习</li>
<li>激发潜能每个人都蕴含着自己想像不到的巨大潜力</li>
<li>不要压抑自己的潜能</li>
<li>保持身体健康</li>
<li>释放积极的力量</li>
<li>敢说真话</li>
<li>掌控负面情绪</li>
<li>分清轻重缓急</li>
<li>设定最后期限</li>
<li>拥有坚定的毅力</li>
<li>如何避免掉入陷阱巧妙</li>
<li>解决生活中的冲突</li>
<li>提高你的专注力</li>
<li>对自己负责</li>
<li>坦然面对胜败</li>
<li>切记：过犹不及</li>
<li>不要偷懒</li>
<li>好好保护自己</li>
<li>别沉迷胜利</li>
<li>拒绝虚荣</li>
<li>拥有适度的幽默感</li>
<li>坚持不懈</li>
<li>不要苛求完美</li>
</ul>


<p>结束语：</p>

<p>DNA决定了人的潜能，只有追求精益求精，才能将其充分释放。无论年龄、背景、资历，任何人都可以踏上这条求索之路。但下定决心踏上这条求索之路并不容易，伴随它而来的是持续学习、终生学习。在这条路上，光辉的成就永远在前方。你会不断进步、不断收获成功，但更重要的是在进步和成功之后继续前进。精益求精的求索将永不停歇。</p>

<p><strong>如何上路？请勇敢地踏出第一步。</strong></p>

<p><strong>何时动身？抓紧现在，时不我待。</strong></p>

<blockquote><p>大智若愚，愚者有时才是真正的智者。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[高效使用Git]]></title>
    <link href="http://strivingboy.github.io/blog/2015/06/17/git-doc/"/>
    <updated>2015-06-17T22:40:55+08:00</updated>
    <id>http://strivingboy.github.io/blog/2015/06/17/git-doc</id>
    <content type="html"><![CDATA[<p>最近给项目组小伙伴讨论了下如何高效使用git，于是在之前几篇基础上＋网络资料整理文档如下，在此记录下：</p>

<h3>核心概念</h3>

<p>谈到Git，最先需要明确的几个概念:</p>

<ul>
<li><p>WorkSpace：工作区，即从仓库中checkout出来的，需要通过Git进行版本控制的目录和文件，可以简单的理解为在文件系统里真实看到的文件</p></li>
<li><p>Stage(Index)：暂存区，或者叫做待提交更新区；在提交进入Repository之前，可以把所有的更新放在暂存区, 用 git add 的文件都在这里</p></li>
<li><p>Repository(Remote/Local)：仓库，一个存放在远端／本地的版本库，用git commit提交的文件就到Local Repository,用git push提交的文件就到Remote Repository</p></li>
<li><p>.git：存放Git管理信息的目录，初始化仓库的时候会自动创建。</p></li>
</ul>


<p>有了上面概念的了解，下面就开始上干货，为了方便图解，用xcode创建一个本地TestGit工程来取景</p>

<!--more-->


<h3>创建仓库</h3>

<p>这个没什么好说的就简单列下：</p>

<p><code>git init</code> 命令用来创建一个新的git仓库，大部分命令都是在git仓库下运行</p>

<p><code>git clone</code> 命令用来复制一个已经存在的 git 仓库</p>

<h3>跟踪本地修改（Stage）</h3>

<p><code>git add</code> 命令用来跟踪本地修改，为接下来的提交做准备，有以下三种姿势：</p>

<p><code>git add &lt;file&gt;</code> 跟踪单个文件(file)修改</p>

<p><code>git add &lt;directory&gt;</code> 跟踪目录(directory)下所有修改</p>

<p><code>git add .</code> 跟踪当前目录及子目录下所有修改</p>

<p>eg: 创建一个TestView.h .m文件 add 后， git status 后效果如下：</p>

<div align=center>
<img src="http://strivingboy.github.io/images/git1.png" width="406" height="164"/>
</div>


<p>上面的<code>gst</code> 是 <code>git status</code> 的别名，后面说下 <code>git alias</code> 接下来就是commit</p>

<h3>commit的几种姿势</h3>

<p><code>git commit</code> 提交本地修改，启动文本编辑器，编辑提交信息</p>

<p><code>git commit -m"message"</code> 提交本地修改，直接编辑提交信息，不启动文本编辑器</p>

<p><code>git commit -a</code>提交本地工作目录下所有修改，而不需要先 <code>git add</code>,相当于：<code>git add</code> 和 <code>git commit</code></p>

<p><code>git commit -am"message"</code>同 <code>git commit -a</code> 只是不启动文本编辑器</p>

<p>这时提交上面的修改如下：</p>

<div align=center>
<img src="http://strivingboy.github.io/images/git2.png" width="337" height="130"/>
</div>


<p>查看log如下：</p>

<div align=center>
<img src="http://strivingboy.github.io/images/git3.png" width="442" height="82"/>
</div>


<p>伙计们，有没有发现跟正常的git log 不一样的地方呢^_^, 请看后面 <strong>更好的changelog</strong></p>

<p>客官别急，还没出大招呢</p>

<p><code>git commit --amend -m"message"</code> 将当前的更改加入上一次commit中并更改最后一次commit的信息。其实观察可发现新的commit是替换了原先的commit，因为commit的hash已经变了。(ps:使用场景：当我们发现上次提交有遗漏的地方，想将修改加入上次提交时 用它是不是很方便^_^)</p>

<p>eg:修改了如下文件，想合并到上次提交</p>

<div align=center>
<img src="http://strivingboy.github.io/images/git4.png" width="534" height="305"/>
</div>


<p>再来看提交纪录， 刚才的commit 1 修改为 commit 1 patch</p>

<div align=center>
<img src="http://strivingboy.github.io/images/git5.png" width="518" height="49"/>
</div>


<p>OK，接下来献上<code>git checkout</code> <strong>重臣</strong>登场</p>

<h3>checkout 技能</h3>

<p>之所以将<code>git checkout</code> 称为<strong>重臣</strong>，因为它有两类技能：一个是分支相关的操作，另一个是可以恢复文件到之前的某个状态。</p>

<ul>
<li>创建分之和切换分之</li>
</ul>


<p><code>git checkout －b branch1</code>创建一个名为&#8221;branch1&#8221;的分支并切换过去，相当于 <code>git branch branch1</code> + <code>git checkout branch1</code></p>

<p>eg:创建分之 “branch1” 并做一次提交 “commit 2”</p>

<div align=center>
<img src="http://strivingboy.github.io/images/git6.png" width="549" height="290"/>
</div>


<p>此刻log如下：</p>

<div align=center>
<img src="http://strivingboy.github.io/images/git7.png" width="531" height="55"/>
</div>


<ul>
<li>恢复到之前的某次提交</li>
</ul>


<p>继续在branch1上做两次提交 “commit 3” 和 “commit 4”, 这时想查看 &ldquo;commit 2&#8221;时代码的样子或作些修改，<code>git checkout &lt;hash&gt;</code> 就跑出来帮你了^_^</p>

<p>……在branch1分之上码着代码，小手抖了一下，嚓，上次提交代码有问题，这时，三位小弟蹦出来，<code>git reset</code>, <code>git checkout</code>, <code>git revert</code> 小弟出来到：哥哥别慌，选我、选我……</p>

<h3>reset, checkout, revert竞选</h3>

<p><code>git reset</code>、<code>git checkout</code>和<code>git revert</code>都是用来撤销对代码仓库的各种修改，前两个命令可以操作提交或单个文件，他们如此相似，来各自秀下自己的技能：</p>

<p><code>Reset</code>:命令可以撤销当前分支的某些提交，如：<code>git reset HEAD^2</code>当前分支回退了两次提交，<code>Reset</code>命令对于想撤销某些提交（前提是当前分支只有自己提交）时非常方便，<code>Reset</code>命令有一下标记：</p>

<ul>
<li>&ndash;soft:使用该标记不会影响暂存区和工作区</li>
<li>&ndash;mixed:使用该标记后，暂存区会更新到了指定的提交，工作区不影响，该标记是默认的</li>
<li>&ndash;hard:暂存区和工作区均更新到指定提交</li>
</ul>


<p><code>git reset --mixed HEAD</code> 会将本地暂存的修改从暂存区取出来，如果想彻底删除未提交的修改，可以使用<code>git reset --hard HEAD</code> （危险：本地修改将不会恢复了哦）<code>Reset</code>炫技完毕</p>

<p><code>Checkout</code>:应该非常熟悉了，首先就是切换分支：</p>

<p><code>git checkout develop</code> git 内部会将HEAD游标移动到master分支，并且更新工作区，因为它会重写本地修改，所以git强制我们在<code>Checkout</code>之前去提交或暂存工作区中的修改。</p>

<p><code>git checkout .</code> 注意该命令危险！它和 <code>git reset --hard HEAD</code> 类似，会彻底删除未提交的修改,不可恢复。可怕&hellip;</p>

<p><code>Revert</code>:命令是用一个新的提交来撤销某次历史提交，不会重写提交历史，是安全可恢复的。因此可用于公开提交的分支，这点与<code>Reset</code>不同，<code>Reset</code>仅用于私有特性分支。虽然我弱小，但是我很专一Y(^_^)Y</p>

<p>……这时 <code>git reset</code>胜出：无图无真相啊</p>

<div align=center>
<img src="http://strivingboy.github.io/images/git8.png" width="553" height="206"/>
</div>


<p>修改完代码，<code>git diff</code>检察官道：看你那么慌，检查一下修改哇，好好好,就敲两个字母嘛
<code>gd</code>， <code>git diff</code>的别名</p>

<div align=center>
<img src="http://strivingboy.github.io/images/git9.png" width="468" height="290"/>
</div>


<p>嚓，小手又抖了，赶紧改去……</p>

<p>特性功能终于码完了，必然和合并到主分之，<code>git merge</code> 和 ｀<code>git rebase</code>两位大将同时现身</p>

<h3>merge VS rebase</h3>

<p>假如现在分支情况如下：</p>

<div align=center>
<img src="http://strivingboy.github.io/images/01.svg" width="468" height="290"/>
</div>


<p><strong>Merge 先来</strong></p>

<p>最简单的操作就是将branch1分支合并到develop，如下：</p>

<pre><code>git checkout feature_branch
git merge master
</code></pre>

<p>或者</p>

<pre><code>git merge master feature_branch
</code></pre>

<p>最终会在develop上创建一个新的合并提交记录。</p>

<p><code>merging</code> 是一个友好的命令，因为它是一个没有破坏性的操作，现有的分支不会有任何形式的改变，因此也就避免了<code>rebasing</code> 一些潜在的缺陷, 相反，这就意味着每一次<code>merging</code>都会在develop会遗留一次额外的提交，当develop开的分支非常活跃时，这将导致branch1&hellip;.N分支的历史记录初步变大，这时查看工程历史记录，就会发现各种分叉，很难理解。</p>

<p>merge后的效果如下：</p>

<div align=center>
<img src="http://strivingboy.github.io/images/02.svg" width="468" height="290"/>
</div>


<p><strong>Rebasing</strong></p>

<p>作为<code>merging</code>的替代方法，我们也可以将branch1分支rebase到develop分支，命令如下：</p>

<pre><code>git checkout feature_branch
git rebase master
</code></pre>

<p>结果将branch1上所有提交移动到了develop分支的最前面，很高效，但与 merge 不同的是 rebase会重写工程提交历史，就像是在develop上重新提交了一遍一样,而不是想merge那样创建一个新的合并提交记录。</p>

<p><code>rebasing</code>最大的优点便是它可以得到一个很清晰的历史记录，首先，它避免了<code>merging</code>产生的那个不必要的提交记录，其次，<code>rebasing</code>的结果是一个完美的线型提交历史，可以很清楚的看到工程的变化。当然：<code>rebasing</code>也存在潜在的问题：1、安全性（在下面的rebase黄金法则中介绍） 2、可追溯性，即：<code>rebasing</code>或失去 <code>merging</code>创建的合并记录，从而无法查看合并记录点。</p>

<p>merge后的效果如下：</p>

<div align=center>
<img src="http://strivingboy.github.io/images/03.svg" width="468" height="290"/>
</div>


<p><strong>Rebasing黄金法则</strong></p>

<p>理解了<code>rebasing</code>的使用，下来就是何时使用:<code>The golden rule is to never use it on public branches.</code></p>

<p>Example：
假设你讲master 分支rebase 到 feature_brauch分支,结果将master上所有提交移动到feature_brauch的最前面，问题是：这次合并操作只影响feature_brauch分支，所有其他开发这依然在original master分支上工作，由于<code>rebasing</code>是重写提交历史，git 会认为所有历史提交已经与其他开发者提交的不同，同步这两个分支唯一的办法是将feature_brauch分支又<code>merging</code>到master分支，结果是两次提交集合中大部分包含了相同的修改，不用说,这是一个非常混乱的局面。因此，当执行<code>rebasing</code>操作时，时常问下自己：<code>是不是有其他人在关注改分支？</code>如果是，则考虑其它方式，否则则可以安全使用<code>rebasing</code>。</p>

<h3>多人多分开发push之三步曲</h3>

<p>当多人在同一个分支开发，每次push前都会经历三部：
＋ <code>git fetch</code> 从远端将队友提交的代码拉下来 （此时在暂存区）
＋ <code>git rebase</code> 和本地代码合并（实际上是将自己的修改重新提交了一遍，至最新提交）， 如果遇到冲突，解决后， git rebase &ndash;continue即可
＋ <code>git push</code> 推送本地提交到远端</p>

<p>三步是不是有点繁琐？答案是：YES， <code>git pull</code>悍将还没出来呢？</p>

<p>git 默认的 <code>git pull</code> 命令相当于 <code>git fetch</code> + <code>git merge</code> (PS：这也是我们的体检记录无法直视的罪魁祸首) ,怎样将 <code>git pull</code> 改为 <code>git fetch</code> + <code>git rebase</code>呢？ Linus Torvalds 大神当然也会考虑到，使用配置: <code>git config</code></p>

<p><code>git config --global branch.autosetuprebase always</code> 加了 &ndash;global 将所有需要合并的操作改为 rebase 而不是 merge ,除非刻意使用 git merge</p>

<h3>更好的changelog</h3>

<p><code>git log</code>一定非常熟悉，如：</p>

<p> git log  命令是查看全部提交日志</p>

<p> git log -2  查看最近2次的提交日志</p>

<p> git log -p  查看历史纪录以来哪几行被修改</p>

<p> git log &ndash;oneline 查看历史提交日志，单行显示</p>

<p>如何更好的使用git log来解决使用过程中遇到的需求：（大家有木有遇到呢&hellip;）</p>

<p><strong>提交历史搜索</strong></p>

<p><code>git log --author="&lt;pattern&gt;"</code></p>

<p>根据提交作者，搜索提交历史 pattern 可以是字符串或这则表达式</p>

<p><code>git log --grep="&lt;pattern&gt;"</code></p>

<p>搜索提交历史 同上pattern 可以是字符串或这则表达式</p>

<p><strong>更清楚的显示单行提交历史</strong></p>

<p><code>git log --pretty=oneline</code> 显示如下：</p>

<div align=center>
<img src="http://strivingboy.github.io/images/git10.png" width="419" height="85"/>
</div>


<p>如何图形化显示更清晰的提交历史呢？</p>

<p><code>git log --graph --decorate --pretty=oneline --abbrev-commit --all</code></p>

<div align=center>
<img src="http://strivingboy.github.io/images/git11.png" width="392" height="90"/>
</div>


<p>能不能再漂亮一点呢？比如：显示提交时间、作者&hellip;..当然可以啦</p>

<p><code>git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit</code></p>

<div align=center>
<img src="http://strivingboy.github.io/images/git12.png" width="491" height="90"/>
</div>


<p>漂亮了有木有^_^，每次打完包测试我们都回写下change log以便测试重点去测,格式随意改……</p>

<p>上面的命令这么长，每次敲岂不累死（前提是要记得住，哈哈), git alias轻松搞定
如：</p>

<p><code>git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</code></p>

<p><strong><a href="https://github.com/robbyrussell/oh-my-zsh">oh-my-zsh</a></strong>中git 插件中提供了很多基础git别名, 个人上面使用的配置 (~/.gitconfig)如下：</p>

<div align=center>
<img src="http://strivingboy.github.io/images/git13.png" width="607" height="340"/>
</div>


<h3>常用点补充</h3>

<ul>
<li><code>git stash</code>
开发中我们经常也会遇到，代码写了一半，要切到另一个分支修复一个bug,或者需要拉取其他小伙伴的代码合并做测试，这时便可以使用 <code>git stash</code>经未完成的放在stash 栈中，相关命令有 :</li>
</ul>


<p><code>stash list</code>:列出stash 所有记录</p>

<p><code>stash apply</code>:将某个纪录取出</p>

<p><code>stash clear</code>:清空stash 栈</p>

<p>……</p>

<ul>
<li><code>git cherry-pick</code></li>
</ul>


<p>当多人在不同分支开发一个版本时，经常也会遇到 A分之上的小伙伴A debug需要B分之上小伙伴B的某次或多次提交， 这时 <code>git cherry-pick</code>朋友值得拥有</p>

<h3>More</h3>

<p><code>git hooks</code> 顾名思义 hook, 比如：在push一条commit之后自动给相关伙伴发邮件等,没有实际应用过……</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac 录制屏幕 & 制作gif]]></title>
    <link href="http://strivingboy.github.io/blog/2015/06/08/gif/"/>
    <updated>2015-06-08T23:57:55+08:00</updated>
    <id>http://strivingboy.github.io/blog/2015/06/08/gif</id>
    <content type="html"><![CDATA[<h3>使用QuickTime Player录制屏幕</h3>

<p><strong>Step1:</strong>  打开QuickTime Player之后直接在顶部栏中QuickTime Player的文件菜单栏下找“新建屏幕录制”或直接使用快捷键“control+command+N”调出屏幕录制工具</p>

<div align=center>
<img src="http://strivingboy.github.io/images/step1.png" width="392" height="335" alt="demo gif"/>
</div>


<p><strong>Step2:</strong>  调出窗口如下图，点击中间的小红点录制按钮屏幕中央也会出现“点按以录制全屏幕。拖动以录制屏幕的一部分。</p>

<!--more-->




<div align=center>
<img src="http://strivingboy.github.io/images/step2.png" width="718" height="284" alt="demo gif"/>
</div>


<p><strong>Step3:</strong>  选择好固定区域后点击屏幕中央的“开始录制”按钮即开始进行屏幕的操作录制，包括鼠标的移动。</p>

<h3>使用photoshop 将视频转换为gif图片</h3>

<p><strong>Step1:</strong> 使用photoshop打开视频之后, 选择［窗口］->[时间轴] 开启时间轴面板，</p>

<div align=center>
<img src="http://strivingboy.github.io/images/step3.png" width="842" height="521" alt="demo gif"/>
</div>


<p><strong>Step2:</strong> 点开时间轴面板右上的扩展菜单按钮，选择 [转换帧]->[转换为帧动画]</p>

<div align=center>
<img src="http://strivingboy.github.io/images/step4.png" width="773" height="372" alt="demo gif"/>
</div>


<p><strong>Step3:</strong>完成后选择 [文件] -> [存储为Web和设备所用格式…]，右上角下拉框中选择 GIF 格式，点击 [存储]</p>

<div align=center>
<img src="http://strivingboy.github.io/images/step5.png" width="600" height="182" alt="demo gif"/>
</div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ios 循环滚动 cycleScrollView]]></title>
    <link href="http://strivingboy.github.io/blog/2015/05/11/cyclescrollview/"/>
    <updated>2015-05-11T19:34:43+08:00</updated>
    <id>http://strivingboy.github.io/blog/2015/05/11/cyclescrollview</id>
    <content type="html"><![CDATA[<p>最近项目中需要一个循环滚动的效果，做法在此记录下哈</p>

<p>实现原理：UIScrollView适中保持三个view，即：前、中、后 三个视图，前后滑动都显示中间那个view</p>

<p>Demo 见：<strong><a href="https://github.com/strivingboy/CycleScrollViewDemo">CycleScrollViewDeomo</a></strong></p>

<p>效果如下：</p>

<div align=center>
<img src="http://strivingboy.github.io/images/scroll.gif" width="320" height="568" alt="demo gif"/>
</div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ios7 在自定义leftBarButtonItem情况下的右滑返回问题]]></title>
    <link href="http://strivingboy.github.io/blog/2014/12/07/ios7-interactive-pop-with-custom-back-button/"/>
    <updated>2014-12-07T20:35:54+08:00</updated>
    <id>http://strivingboy.github.io/blog/2014/12/07/ios7-interactive-pop-with-custom-back-button</id>
    <content type="html"><![CDATA[<p>最近在做项目时发现一个问题：在自定义navigation 的 leftBarButtonItem后，右滑pop 手势失效了，google 了一把，解决过程如下，在此记录下：</p>

<p>问题：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="nb">self</span><span class="p">.</span><span class="n">navigationItem</span><span class="p">.</span><span class="n">leftBarButtonItem</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">backButton</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">UIBarButtonItem</span> <span class="o">*</span><span class="p">)</span><span class="nf">backButton</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="bp">UIImage</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageNamed</span><span class="p">:</span><span class="s">@&quot;back_button&quot;</span><span class="p">];</span>
</span><span class='line'>  <span class="bp">CGRect</span> <span class="n">buttonFrame</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">image</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="bp">UIButton</span> <span class="o">*</span><span class="n">button</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIButton</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame</span><span class="p">:</span><span class="n">buttonFrame</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[</span><span class="n">button</span> <span class="nl">addTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">action</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">backButtonPressed</span><span class="p">)</span> <span class="nl">forControlEvents</span><span class="p">:</span><span class="n">UIControlEventTouchUpInside</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[</span><span class="n">button</span> <span class="nl">setImage</span><span class="p">:[</span><span class="bp">UIImage</span> <span class="nl">imageNamed</span><span class="p">:</span><span class="n">normalImage</span><span class="p">]</span> <span class="nl">forState</span><span class="p">:</span><span class="n">UIControlStateNormal</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="bp">UIBarButtonItem</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIBarButtonItem</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithCustomView</span><span class="p">:</span><span class="n">button</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="n">item</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>当写完上述代码后，就会发现，iOS7提供的右滑返回手势不起作用了，这篇<a href="http://stuartkhall.com/posts/ios-7-development-tips-tricks-hacks">ios 7 Tips</a>文章中给出了一个快速的解决方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="nb">self</span><span class="p">.</span><span class="n">navigationItem</span><span class="p">.</span><span class="n">leftBarButtonItem</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIBarButtonItem</span> <span class="n">alloc</span><span class="p">]</span>
</span><span class='line'>                                             <span class="nl">initWithImage</span><span class="p">:</span><span class="n">img</span>
</span><span class='line'>                                             <span class="nl">style</span><span class="p">:</span><span class="n">UIBarButtonItemStylePlain</span>
</span><span class='line'>                                             <span class="nl">target</span><span class="p">:</span><span class="nb">self</span>
</span><span class='line'>                                             <span class="nl">action</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">onBack</span><span class="p">:)];</span>
</span><span class='line'><span class="nb">self</span><span class="p">.</span><span class="n">navigationController</span><span class="p">.</span><span class="n">interactivePopGestureRecognizer</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="p">(</span><span class="kt">id</span><span class="o">&lt;</span><span class="bp">UIGestureRecognizerDelegate</span><span class="o">&gt;</span><span class="p">)</span><span class="nb">self</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>经过测试发现当 push 一个 viewController后快速 右滑返回会导致崩溃， 也就是说在当push动画还没完成时去滑动返回， navigation controller 还在引用 viewController， 调试模式下回看到如下log:</p>

<p><em>nested pop animation can result in corrupted navigation bar</em></p>

<p>下来就是想办法在动画过程中禁止滑动手势，于是就有了下面的解决方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">@interface</span> <span class="nc">BaseNavigationController</span> : <span class="bp">UINavigationController</span> <span class="o">&lt;</span><span class="bp">UINavigationControllerDelegate</span><span class="p">,</span> <span class="bp">UIGestureRecognizerDelegate</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">BaseNavigationController</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">__weak</span> <span class="n">BaseNavigationController</span> <span class="o">*</span><span class="n">weakSelf</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">([</span><span class="nb">self</span> <span class="nl">respondsToSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">interactivePopGestureRecognizer</span><span class="p">)])</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">interactivePopGestureRecognizer</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">weakSelf</span><span class="p">;</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">weakSelf</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Hijack the push method to disable the gesture</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">pushViewController:</span><span class="p">(</span><span class="bp">UIViewController</span> <span class="o">*</span><span class="p">)</span><span class="nv">viewController</span> <span class="nf">animated:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">([</span><span class="nb">self</span> <span class="nl">respondsToSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">interactivePopGestureRecognizer</span><span class="p">)])</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">interactivePopGestureRecognizer</span><span class="p">.</span><span class="n">enabled</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">[</span><span class="nb">super</span> <span class="nl">pushViewController</span><span class="p">:</span><span class="n">viewController</span> <span class="nl">animated</span><span class="p">:</span><span class="n">animated</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark UINavigationControllerDelegate</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">navigationController:</span><span class="p">(</span><span class="bp">UINavigationController</span> <span class="o">*</span><span class="p">)</span><span class="nv">navigationController</span>
</span><span class='line'>       <span class="nf">didShowViewController:</span><span class="p">(</span><span class="bp">UIViewController</span> <span class="o">*</span><span class="p">)</span><span class="nv">viewController</span>
</span><span class='line'>                    <span class="nf">animated:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animate</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="c1">// Enable the gesture again once the new controller is shown</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">([</span><span class="nb">self</span> <span class="nl">respondsToSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">interactivePopGestureRecognizer</span><span class="p">)])</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">interactivePopGestureRecognizer</span><span class="p">.</span><span class="n">enabled</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong> 参考链接 </strong></p>

<ul>
<li><u><a href="http://stuartkhall.com/posts/ios-7-development-tips-tricks-hacks">http://stuartkhall.com/posts/ios-7-development-tips-tricks-hacks</a> </u></li>
<li><u><a href="http://keighl.com/post/ios7-interactive-pop-gesture-custom-back-button/">http://keighl.com/post/ios7-interactive-pop-gesture-custom-back-button/</a> </u></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS8 Day-by-Day :: Day 1 :: swift学习指南]]></title>
    <link href="http://strivingboy.github.io/blog/2014/11/27/ios8daybyday-swfit/"/>
    <updated>2014-11-27T16:21:13+08:00</updated>
    <id>http://strivingboy.github.io/blog/2014/11/27/ios8daybyday-swfit</id>
    <content type="html"><![CDATA[<p>这篇文章是iOS8 Day-by-Day系列的一部分，你可以查看完整的系列目录：<a href="http://strivingboy.github.io/blog/2014/11/27/ios8daybyday/">iOS8 Day-by-Day 系列文章</a></p>

<p><strong>介绍</strong></p>

<p>今年的WWDC大会真让人难以置信,除了宣布iOS8之外,他们还引入了一个新的编程语言Swfit。这跟objective-c这种强类型的语言有很大的不同,它包括了现代语言一些常见特性。</p>

<p>怀着拥抱一切新东西的心情,这系列的博客将使用swfit。有大量的信息关于如何学习swfit语言,以及如何与cocoa交互——事实上下面这两本官方的书籍不能错过:</p>

<ul>
<li><a href="https://itunes.apple.com/cn/book/swift-programming-language/id881256329?mt=11">The Swift Programming Language</a></li>
<li><a href="https://itunes.apple.com/us/book/using-swift-cocoa-objective/id888894773?mt=11&amp;ls=1">Using Swift with Cocoa and Objective-C</a></li>
</ul>


<p>这两本书的中文版见 github: <a href="https://github.com/CocoaChina-editors/Welcome-to-Swift">Welcome-to-Swift</a></p>

<!--more-->


<p>同时可以参考苹果的<a href="https://developer.apple.com/swift/blog/">Swfit官方博客</a> 以及其它<a href="https://developer.apple.com/swift/resources/">swfit 资源</a></p>

<p>正因为有如此多关于Swfit的资源，本篇文章不会去介绍所有swfit的知识，而是介绍首次使用Swfit容易遇到的一些重要的陷阱以及潜在的问题，特别是和系统框架相关部分。</p>

<p>本章的实例程序github访问地址:<a href="https://github.com/ShinobiControls/iOS8-day-by-day/">github.com/ShinobiControls/iOS8-day-by-day/</a></p>

<p><strong>初始化</strong></p>

<p>关于初始化，swfit 和 objective-c 有很大的不同如下：</p>

<p>objective-c代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">init</span> <span class="p">{</span>
</span><span class='line'>  <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Do some stuff</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>对应的swfit代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">init</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">variableA</span> <span class="o">=</span> <span class="mi">10</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="nb">super</span><span class="p">.</span><span class="n">init</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>objective-c 的初始化方法负责 创建和返回<em>self</em> 而swfit没有<em>return</em> 语句，这就意味着swfit没有任何方式去返回<em>nil</em>对象。
<em>nil</em> 对象在objective-c中通常表示一个失败的初始化，这显然在接下来发布的swfit更新中有可能改掉。</p>

<p><strong>可变对象与不可变对象</strong></p>

<p>可变或不可变对象的概念对Cocoa开发者已经非常熟悉如：<em>NSArray</em> 和 <em>NSMutableArray</em> 在swfit中，<em>let</em>关键字来定义不可变对象，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">let</span> <span class="n">a</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
</span><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="n">MySecondClass</span><span class="p">()</span> <span class="c1">// Not allowed</span>
</span></code></pre></td></tr></table></div></figure>


<p>这就意味这不能重新赋值给<em>let</em>关键字指定的实例。实例的引用能不能重新赋值取决于对象的类型，如果一个实例是<strong>value type</strong>（如结构体）引用了<em>let</em>关键字指定的实例，改实例依然是不可变的，如果引用是一个<strong>class</strong>实例, 则改引用是可变的，具体看下面的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">struct</span> <span class="n">MyStruct</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">let</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">12</span>
</span><span class='line'>  <span class="n">var</span> <span class="nl">u</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果使用<em>var</em>关键字定义一个变量<em>struct1</em> ,你将得到如下行为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">var</span> <span class="n">struct1</span> <span class="o">=</span> <span class="n">MyStruct</span><span class="p">(</span><span class="nl">t</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span> <span class="nl">u</span><span class="p">:</span> <span class="s">&quot;Hello&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">struct1</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="mi">13</span> <span class="c1">// Error: t is an immutable property</span>
</span><span class='line'><span class="n">struct1</span><span class="p">.</span><span class="n">u</span> <span class="o">=</span> <span class="s">&quot;GoodBye&quot;</span>
</span><span class='line'><span class="n">struct1</span> <span class="o">=</span> <span class="n">MyStruct</span><span class="p">(</span><span class="nl">t</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="nl">u</span><span class="p">:</span> <span class="s">&quot;You&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>你可以改变属性<em>u</em>，因为它是通过<em>var</em>关键字定义的，同时也可以变量<em>struct1</em>本身，同样是因为通过<em>var</em>关键字定义的，而不能改变属性<em>t</em>,因为它是通过<em>let</em>关键字定义的，让我们看下使用<em>let</em>关键字定义的一个<em>struct</em>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">let</span> <span class="n">struct2</span> <span class="o">=</span> <span class="n">MyStruct</span><span class="p">(</span><span class="nl">t</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="nl">u</span><span class="p">:</span> <span class="s">&quot;World&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">struct2</span><span class="p">.</span><span class="n">u</span> <span class="o">=</span> <span class="s">&quot;Planet&quot;</span> <span class="c1">// Error: struct2 is immutable</span>
</span><span class='line'><span class="n">struct2</span> <span class="o">=</span> <span class="n">MyStruct</span><span class="p">(</span><span class="nl">t</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="nl">u</span><span class="p">:</span> <span class="s">&quot;Defeat&quot;</span><span class="p">)</span> <span class="c1">// Error: struct2 is an immutable ref</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在，不仅是<em>struct2</em>不可变，而去属性<em>u</em>也是不可变的，这是因为结构体是一个 <strong>value type</strong></p>

<p>对于一个<strong>class</strong>上述行为则有点不同，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">class</span> <span class="n">MyClass</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">let</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">12</span>
</span><span class='line'>  <span class="n">var</span> <span class="nl">u</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">init</span><span class="p">(</span><span class="nl">t</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="nl">u</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">t</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">u</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过<em>var</em>关键字定义一个<em>class</em>实例，行为和使用objective-c类似：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">var</span> <span class="n">class1</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="nl">t</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span> <span class="nl">u</span><span class="p">:</span> <span class="s">&quot;Hello&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">class1</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="mi">13</span> <span class="c1">// Error: t is an immutable property</span>
</span><span class='line'><span class="n">class1</span><span class="p">.</span><span class="n">u</span> <span class="o">=</span> <span class="s">&quot;GoodBye&quot;</span>
</span><span class='line'><span class="n">class1</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="nl">t</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="nl">u</span><span class="p">:</span> <span class="s">&quot;You&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在不仅引用自己是可变的，而且所有通过<em>var</em>关键字定义的属性也是可变的，只是通过<em>let</em>关键字定义的属性是不可变的。作为比较我们来看下使用<em>let</em>关键字定义的实例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">let</span> <span class="n">class2</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="nl">t</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="nl">u</span><span class="p">:</span> <span class="s">&quot;World&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">class2</span><span class="p">.</span><span class="n">u</span> <span class="o">=</span> <span class="s">&quot;Planet&quot;</span> <span class="c1">// No error</span>
</span><span class='line'><span class="n">class2</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="nl">t</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="nl">u</span><span class="p">:</span> <span class="s">&quot;Geoid&quot;</span><span class="p">)</span> <span class="nl">Error</span><span class="p">:</span> <span class="n">class2</span> <span class="n">is</span> <span class="n">an</span> <span class="n">immutable</span> <span class="n">reference</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在自己的引用就是不可变的了，但是<em>var</em>关键字定义的属性是可变的，这是因为一个<em>class</em>是 <strong>reference type</strong></p>

<p>上述行为时比较容易理解的，因为大部分有引用类型的语言书籍都有详细的解释，当使用swfit 集合类型是上述行为就有点困惑，一个 <em>NSArray</em> 是一个<strong>reference type</strong>,也就是说当你创建一个<em>NSArray</em>实例时，就是创建了一指针指向数组所在的一块内存区域（根据objective-c 的定义），如果你根据上面介绍的&#8221;reference type&#8221;不难推理出<em>NSArray</em>的实例也是可变的，实际上，如果要创建一个可变数组，再objective-c中完我们要使用<em>NSMutableArray</em>
Swfit 数组与此不同，它使用<strong>value types</strong> 来代替 <strong>reference types</strong>, 也就意味着在swfit中的行为类似一<em>struct</em>而不是一个<em>class</em>,因此关键字 <em>let</em> 或者<em>var</em> 不仅可以指定变量是否可以重定义，而且还可以指定一个数组实例是否可变。
通过 <em>var</em>定义的数组既可以重新赋值也是可变的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">var</span> <span class="n">array1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</span><span class='line'><span class="n">array1</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  <span class="c1">// [1,2,3,4,5]array1[0] = 27    // [27,2,3,4,5]</span>
</span><span class='line'><span class="n">array1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>    <span class="c1">// [3,2]</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过 <em>var</em>定义的数组两者都不可以：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">let</span> <span class="n">array2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</span><span class='line'><span class="n">array2</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// Error: array2 is immutablearray2[2] = 36   // Error: array2 is immutable</span>
</span><span class='line'><span class="n">array2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>   <span class="c1">// Error: cannot reassign an immutable reference</span>
</span></code></pre></td></tr></table></div></figure>


<p>哦，my god,都晕了，这不仅完全改变了我们对集合可变的认识，而且混谣了上面说的两个概念的区别，这个有个可能在后面swfit语言的发展中会修改，因此保持关注swfit语言的定义。</p>

<p>结论：由于arrays 是 值类型，所以它们通过拷贝来传递，<em>NSArray</em>实例是通过引用来传递，如果在一个方法中传递一个swfit array ，它将对这个数组进行拷贝，至于是深拷贝还是潜拷贝取决于数组中存储的对象。</p>

<p><strong>强类型和任意对象(AnyObject)</strong></p>

<p>强类型是swfit一个很大的特性，使用它可以写出更安全的代码，这使得objective-c在运行时的异常可以在编译时捕获。</p>

<p>这是很强大，但是在objective-c 中我们经常用到 <em>id</em>类型，swfit中对应的就是<em>AnyObject</em>，<em>AnyObject</em> 感觉不像swfit的风格(un-swfit-like)，它允许你调用任何它能找到的方法，但是这将在运行时导致异常。实际上，它的行为和objective-c的<em>id</em>非常相似，区别在于，如果<em>AnyObject</em>对象上没有相应的属性或方法，它将返回<em>nil</em>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">let</span> <span class="nl">myString</span><span class="p">:</span> <span class="n">AnyObject</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span>
</span><span class='line'><span class="n">myString</span><span class="p">.</span><span class="n">cornerRadius</span> <span class="c1">// Returns nil</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了更像Cocoa APIs中的 swfit 风格（swfit-like），下面是很常见的代码模式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">func</span> <span class="n">someFunc</span><span class="p">(</span><span class="nl">parameter</span><span class="p">:</span> <span class="n">AnyObject</span><span class="o">!</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyObject</span><span class="o">!</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">let</span> <span class="n">castedParameter</span> <span class="o">=</span> <span class="n">parameter</span> <span class="n">as</span><span class="o">?</span> <span class="bp">NSString</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Now I know I have a string :)</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果你完全确定传递一个字符串，你没有必要做如上的代码保护，可以直接这样写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">let</span> <span class="n">castedParameter</span> <span class="o">=</span> <span class="n">parameter</span> <span class="n">as</span> <span class="bp">NSString</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>Swift 协议（protocol）</strong></p>

<p>Protocol 在swift中很容易理解如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">protocol</span> <span class="n">MyProtocol</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">myProtocolMethod</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Bool</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>一个常见的情况就是检测一个对象是否符合指定的协议，你可能写下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">class1AsMyProtocol</span> <span class="o">=</span> <span class="n">class1</span> <span class="n">as</span><span class="o">?</span> <span class="n">MyProtocol</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// We&#39;re in</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然而它会导致错误，因为为了检查是否符合某个协议，改协议必须是objective-c 协议，即通过 <em>@objc</em>来指定的协议：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="p">@</span><span class="n">objc</span> <span class="n">protocol</span> <span class="n">MyNewProtocol</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">func</span> <span class="n">myProtocolMethod</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Bool</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="n">let</span> <span class="n">class1AsMyNewProtocol</span> <span class="o">=</span> <span class="n">class1</span> <span class="n">as</span><span class="o">?</span> <span class="n">MyNewProtocol</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// We&#39;re in</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果Swift类继承自Objective-C的类，则它里面的方法和属性都能够作为Objective-C的选择器使用。而如果不是Objective-C的子类，需要使用@objc属性修饰。</p>

<p><strong>枚举</strong></p>

<p>枚举在swfit中变化很大，不仅可以枚举有关联的值（可以使不同类型），而且还方法也可以枚举。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="k">enum</span> <span class="n">MyEnum</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">FirstType</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">IntType</span> <span class="p">(</span><span class="n">Int</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">StringType</span> <span class="p">(</span><span class="n">String</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">TupleType</span> <span class="p">(</span><span class="n">Int</span><span class="p">,</span> <span class="n">String</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">func</span> <span class="n">prettyFormat</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">switch</span> <span class="nb">self</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="p">.</span><span class="nl">FirstType</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="s">&quot;No params&quot;</span>
</span><span class='line'>    <span class="k">case</span> <span class="p">.</span><span class="n">IntType</span><span class="p">(</span><span class="n">let</span> <span class="n">value</span><span class="p">)</span><span class="o">:</span>      <span class="k">return</span> <span class="s">&quot;One param: \(value)&quot;</span>    <span class="k">case</span> <span class="p">.</span><span class="n">StringType</span><span class="p">(</span><span class="n">let</span> <span class="n">value</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="s">&quot;One param: \(value)&quot;</span>
</span><span class='line'>    <span class="k">case</span> <span class="p">.</span><span class="n">TupleType</span><span class="p">(</span><span class="n">let</span> <span class="n">v1</span><span class="p">,</span> <span class="n">let</span> <span class="n">v2</span><span class="p">)</span><span class="o">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="s">&quot;Some params: \(v1), \(v2)&quot;</span>
</span><span class='line'>    <span class="k">default</span><span class="o">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="s">&quot;Nothing to see here&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>真是强大，可以如下使用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">var</span> <span class="n">enum1</span> <span class="o">=</span> <span class="n">MyEnum</span><span class="p">.</span><span class="n">FirstType</span>
</span><span class='line'><span class="n">enum1</span><span class="p">.</span><span class="n">prettyFormat</span><span class="p">()</span> <span class="c1">// &quot;No params&quot;</span>
</span><span class='line'><span class="n">enum1</span> <span class="o">=</span> <span class="p">.</span><span class="n">TupleType</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="s">&quot;Hello&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">enum1</span><span class="p">.</span><span class="n">prettyFormat</span><span class="p">()</span> <span class="c1">// &quot;Some params: 12, Hello&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>总结</strong></p>

<p>Swfit 是一门功能强大的语言，掌握它的最佳实践、惯用方法以及模式需要一段时间，这篇文章列出了一些从objective-c到swfit常见的困惑.</p>

<p>本文翻译自：<a href="http://www.shinobicontrols.com/blog/posts/2014/07/17/ios8-day-by-day-day-1-blaggers-guide-to-swift">ios8-day-by-day-day-1-blaggers-guide-to-swift</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS8 Day-by-Day 系列文章]]></title>
    <link href="http://strivingboy.github.io/blog/2014/11/27/ios8daybyday/"/>
    <updated>2014-11-27T14:12:43+08:00</updated>
    <id>http://strivingboy.github.io/blog/2014/11/27/ios8daybyday</id>
    <content type="html"><![CDATA[<p>看完 Kingiol Ding 翻译的<a href="http://blog.kingiol.com/blog/2014/01/06/introducting-ios7-day-by-day/">天天品尝iOS7甜点</a>系列的文章，又看到 ShinobiControls Team 中 Sam Davies 中关于  iOS8 Day-by-Day 系列的文章，(<a href="http://blog.kingiol.com/blog/2014/01/06/introducting-ios7-day-by-day/">介绍在这里</a>)搜了下没有完整的中文的翻译，于是就萌生了翻译改系列文章的念头，意在锻炼下自己的英文水平，同时学习下iOS8相关知识，非常感谢来自 Kingiol Ding 的动力，同时对Sam Davies作者深感敬佩。</p>

<p>今年6月份的<a href="https://developer.apple.com/wwdc/">WWDC 2014</a> 大会可以说是一次软件开发者的盛宴，开放了4000多个api ，给开发者无限的可能性。
<strong>iOS8 Day-by-Day</strong> 系列文章基本包含了iOS开发者需要知道的所有iOS8新特性以及新技术，下面就逐个介绍这些特性：</p>

<ul>
<li><a href="http://strivingboy.github.io/blog/2014/11/27/ios8daybyday-swfit/">Day 1 :: swfit 学习指南</a></li>
</ul>


<!--more-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 手势（UIGestureRecognizer）操作]]></title>
    <link href="http://strivingboy.github.io/blog/2014/11/15/ios-gestures/"/>
    <updated>2014-11-15T14:14:19+08:00</updated>
    <id>http://strivingboy.github.io/blog/2014/11/15/ios-gestures</id>
    <content type="html"><![CDATA[<p>本文摘自：<a href="http://www.appcoda.com/ios-gesture-recognizers/">AppCoda</a></p>

<p>UIKit中包含了UIGestureRecognizer类来处理手势识别，UIGestureRecognizer是一个抽象类，用于检测发生在UIView上预定义的手势。UIGestureRecognizer 提供了一些子类来处理具体的手势行为，如下：</p>

<ul>
<li><p>UITapGestureRecognizer: 该类处理View上的点击<em>Tap</em>操作（任意手指、任意次数的点击）该操作很常见</p></li>
<li><p>UISwipeGestureRecognizer: 该类处理滑动<em>Swipe</em>操作（上、下、左、右）如：照片应用中滑动查看下一张照片</p></li>
<li><p>UIPanGestureRecognizer: 该类处理拖拽<em>Pan</em>操作，如：将一个View从一个点拖拽到另一个点</p></li>
</ul>


<!--more-->


<ul>
<li><p>UIPinchGestureRecognizer: 该类处理向里或向外捏和<em>Pinch</em>操作 (任意方向)如：放大或缩小某张图片</p></li>
<li><p>UIRotationGestureRecognizer: 该类处理旋转<em>Rotation</em>操作，如：双指旋转某个view</p></li>
<li><p>UILongPressGestureRecognizer: 该类处理长按<em>LongPress</em>操作</p></li>
<li><p>UIScreenEdgePanGestureRecognizer:该类是ios7上添加的，看起来像<em>Pan</em>手势,它是检测屏幕边缘的pan手势的，系统在某些controller转场的时候会使用这个手势。</p></li>
</ul>


<p>所有的手势对象都会执行<em>perform</em>一个响应事件<em>action</em>,手势对象会带有相关属性设置，如：手指数目，点击次数等，我们将手势处理事件定义如下：</p>

<pre><code>    -(void)handleMyTapGestureWithGestureRecognizer:(UITapGestureRecognizer *)gestureRecognizer;
</code></pre>

<p>下面简单说下各个手势的例子，详细代码请查看原文,在原文demo上我添加了UIScreenEdgePanGestureRecognizer的例子,见github：<a href="https://github.com/strivingboy/GestureDemo.git">GestureDemo</a>。</p>

<ul>
<li>UITapGestureRecognizer 代码片段</li>
</ul>


<p>初始化手势：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// 创建 单个手指单次点击 手势对象</span>
</span><span class='line'><span class="bp">UITapGestureRecognizer</span> <span class="o">*</span><span class="n">singleTapGestureRecognizer</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UITapGestureRecognizer</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">action</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">handleSingleTapGesture</span><span class="p">:)];</span>
</span><span class='line'><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">testView</span> <span class="nl">addGestureRecognizer</span><span class="p">:</span><span class="n">singleTapGestureRecognizer</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 创建 双手指两次点击 手势对象</span>
</span><span class='line'><span class="bp">UITapGestureRecognizer</span> <span class="o">*</span><span class="n">doubleTapGestureRecognizer</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UITapGestureRecognizer</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">action</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">handleDoubleTapGesture</span><span class="p">:)];</span>
</span><span class='line'><span class="n">doubleTapGestureRecognizer</span><span class="p">.</span><span class="n">numberOfTapsRequired</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'><span class="n">doubleTapGestureRecognizer</span><span class="p">.</span><span class="n">numberOfTouchesRequired</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">testView</span> <span class="nl">addGestureRecognizer</span><span class="p">:</span><span class="n">doubleTapGestureRecognizer</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>手势响应事件</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="p">-(</span><span class="kt">void</span><span class="p">)</span><span class="nf">handleSingleTapGesture:</span><span class="p">(</span><span class="bp">UITapGestureRecognizer</span> <span class="o">*</span><span class="p">)</span><span class="nv">tapGestureRecognizer</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 处理单次点击事件</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">-(</span><span class="kt">void</span><span class="p">)</span><span class="nf">handleDoubleTapGesture:</span><span class="p">(</span><span class="bp">UITapGestureRecognizer</span> <span class="o">*</span><span class="p">)</span><span class="nv">tapGestureRecognizer</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="c1">// 处理双手指两次点击事件</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>UISwipeGestureRecognizer 代码片段</li>
</ul>


<p>初始化手势：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// 创建 滑动 手势对象</span>
</span><span class='line'><span class="bp">UISwipeGestureRecognizer</span> <span class="o">*</span><span class="n">swipeRightOrange</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UISwipeGestureRecognizer</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">action</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">slideToRightWithGestureRecognizer</span><span class="p">:)];</span>
</span><span class='line'><span class="c1">// 滑动方向</span>
</span><span class='line'><span class="n">swipeRightOrange</span><span class="p">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">UISwipeGestureRecognizerDirectionRight</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">viewOrange</span> <span class="nl">addGestureRecognizer</span><span class="p">:</span><span class="n">swipeRightOrange</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>手势响应事件</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'>  <span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">slideToRightWithGestureRecognizer</span><span class="p">:(</span><span class="bp">UISwipeGestureRecognizer</span> <span class="o">*</span><span class="p">)</span><span class="n">gestureRecognizer</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>      <span class="c1">// 处理向右滑动事件</span>
</span><span class='line'>      <span class="p">...</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>UIPanGestureRecognizer 代码片段</li>
</ul>


<p>初始化手势：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// 创建 拖拽 手势对象</span>
</span><span class='line'><span class="bp">UIPanGestureRecognizer</span> <span class="o">*</span><span class="n">panGestureRecognizer</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIPanGestureRecognizer</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">action</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">moveViewWithGestureRecognizer</span><span class="p">:)];</span>
</span><span class='line'><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">testView</span> <span class="nl">addGestureRecognizer</span><span class="p">:</span><span class="n">panGestureRecognizer</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>手势响应事件</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'>  <span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">moveViewWithGestureRecognizer</span><span class="p">:(</span><span class="bp">UIPanGestureRecognizer</span> <span class="o">*</span><span class="p">)</span><span class="n">panGestureRecognizer</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>      <span class="c1">// 处理拖拽事件</span>
</span><span class='line'>      <span class="p">...</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>UIPinchGestureRecognizer 代码片段</li>
</ul>


<p>初始化手势：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// 创建 捏合 手势对象</span>
</span><span class='line'><span class="bp">UIPinchGestureRecognizer</span> <span class="o">*</span><span class="n">pinchGestureRecognizer</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIPinchGestureRecognizer</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">action</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">handlePinchWithGestureRecognizer</span><span class="p">:)];</span>
</span><span class='line'><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">testView</span> <span class="nl">addGestureRecognizer</span><span class="p">:</span><span class="n">pinchGestureRecognizer</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>手势响应事件</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'>  
</span><span class='line'><span class="p">-(</span><span class="kt">void</span><span class="p">)</span><span class="nf">handlePinchWithGestureRecognizer:</span><span class="p">(</span><span class="bp">UIPinchGestureRecognizer</span> <span class="o">*</span><span class="p">)</span><span class="nv">pinchGestureRecognizer</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 处理捏合事件</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>UIRotationGestureRecognizer 代码片段</li>
</ul>


<p>初始化手势：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// 创建 旋转 手势对象</span>
</span><span class='line'><span class="bp">UIRotationGestureRecognizer</span> <span class="o">*</span><span class="n">rotationGestureRecognizer</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIRotationGestureRecognizer</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">action</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">handleRotationWithGestureRecognizer</span><span class="p">:)];</span>
</span><span class='line'><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">testView</span> <span class="nl">addGestureRecognizer</span><span class="p">:</span><span class="n">rotationGestureRecognizer</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>手势响应事件</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'>  
</span><span class='line'><span class="p">-(</span><span class="kt">void</span><span class="p">)</span><span class="nf">handleRotationWithGestureRecognizer:</span><span class="p">(</span><span class="bp">UIRotationGestureRecognizer</span> <span class="o">*</span><span class="p">)</span><span class="nv">rotationGestureRecognizer</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 处理旋转事件</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>UILongPressGestureRecognizer 代码片段</li>
</ul>


<p>初始化手势：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="c1">// 创建 长按 手势对象</span>
</span><span class='line'><span class="bp">UILongPressGestureRecognizer</span> <span class="o">*</span><span class="n">longPressGestureRecognizer</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UILongPressGestureRecognizer</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">action</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">handleLongPressWithGestureRecognizer</span><span class="p">:)];</span>
</span><span class='line'><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">testView</span> <span class="nl">addGestureRecognizer</span><span class="p">:</span><span class="n">longPressGestureRecognizer</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>手势响应事件</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'>  
</span><span class='line'><span class="p">-(</span><span class="kt">void</span><span class="p">)</span><span class="nf">handleLongPressWithGestureRecognizer:</span><span class="p">(</span><span class="bp">UILongPressGestureRecognizer</span> <span class="o">*</span><span class="p">)</span><span class="nv">longPressGestureRecognizer</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 处理长按事件</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>UIScreenEdgePanGestureRecognizer 代码片段</li>
</ul>


<p>初始化手势：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'> <span class="c1">// 创建屏幕边缘手势(优先级高于其他手势)</span>
</span><span class='line'><span class="bp">UIScreenEdgePanGestureRecognizer</span> <span class="o">*</span><span class="n">edgePanGestureRecognizer</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIScreenEdgePanGestureRecognizer</span> <span class="n">alloc</span><span class="p">]</span>
</span><span class='line'>                                                              <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span>
</span><span class='line'>                                                              <span class="nl">action</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">handleEdgePanWithGestureRecognizer</span><span class="p">:)];</span>
</span><span class='line'><span class="n">edgePanGestureRecognizer</span><span class="p">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">UIRectEdgeLeft</span><span class="p">;</span>           <span class="c1">// 左侧边缘响应</span>
</span><span class='line'><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span> <span class="nl">addGestureRecognizer</span><span class="p">:</span><span class="n">edgePanGestureRecognizer</span><span class="p">];</span> <span class="c1">// view添到self.view上</span>
</span></code></pre></td></tr></table></div></figure>


<p>手势响应事件</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'>
</span><span class='line'><span class="p">-(</span><span class="kt">void</span><span class="p">)</span><span class="nf">handleEdgePanWithGestureRecognizer:</span><span class="p">(</span><span class="bp">UIScreenEdgePanGestureRecognizer</span> <span class="o">*</span><span class="p">)</span><span class="nv">gesture</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">UIGestureRecognizerStateBegan</span> <span class="o">==</span> <span class="n">gesture</span><span class="p">.</span><span class="n">state</span> <span class="o">||</span>
</span><span class='line'>       <span class="n">UIGestureRecognizerStateChanged</span> <span class="o">==</span> <span class="n">gesture</span><span class="p">.</span><span class="n">state</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 根据被触摸手势的view计算得出坐标值</span>
</span><span class='line'>        <span class="bp">CGPoint</span> <span class="n">translation</span> <span class="o">=</span> <span class="p">[</span><span class="n">gesture</span> <span class="nl">translationInView</span><span class="p">:</span><span class="n">gesture</span><span class="p">.</span><span class="n">view</span><span class="p">];</span>
</span><span class='line'>        <span class="n">_showView</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">translation</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS使用AVFoundation实现二维码扫描]]></title>
    <link href="http://strivingboy.github.io/blog/2014/11/08/scan-qrcode/"/>
    <updated>2014-11-08T14:30:57+08:00</updated>
    <id>http://strivingboy.github.io/blog/2014/11/08/scan-qrcode</id>
    <content type="html"><![CDATA[<p>关于二维码扫描有不少优秀第三方库如：</p>

<ul>
<li><p><a href="http://zbar.sourceforge.net/iphone/sdkdoc/index.html">ZBar SDK</a> 里面有详细的文档，相应介绍也非常多，如：<u><a href="http://rdcworld-iphone.blogspot.in/2013/03/how-to-use-barcode-scanner-br-and-qr-in.html">http://rdcworld-iphone.blogspot.in/2013/03/how-to-use-barcode-scanner-br-and-qr-in.html</a></u></p></li>
<li><p><a href="https://github.com/zxing/zxing">ZXing</a> google推出的开源项目，相应介绍如：<u><a href="http://blog.devtang.com/blog/2012/12/23/use-zxing-library/">http://blog.devtang.com/blog/2012/12/23/use-zxing-library/</a></u></p></li>
</ul>


<p>最近项目需要，看了下使用ios7自带的 AVFoundation Framework 来实现二维码扫描，Demo 见：<a href="https://github.com/strivingboy/scan_qrcode_demo.git">scan_qrcode_demo</a></p>

<p><strong>关于AVFoundation</strong></p>

<!--more-->


<p>AVFoundation 是一个很大基础库，用来创建基于时间的视听媒体，可以使用它来检查,创建、编辑或媒体文件。也可以输入流从设备和操作视频实时捕捉和回放。详细框架介绍见官网：<a href="https://developer.apple.com/library/mac/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/00_Introduction.html">About AV Foundation</a>，本文只是介绍如果使用AVFoundation获取二维码。</p>

<p>首先获取流媒体信息我们需要<code>AVCaptureSession</code>对象来管理输入流和输出流，<code>AVCaptureVideoPreviewLayer</code>对象来显示信息，基本流程如下图所示：</p>

<p><img src="http://strivingboy.github.com/images/2014-11-08-flow.jpg" alt="scan_qr_code_flow" /></p>

<p>注：</p>

<ul>
<li><code>AVCaptureSession</code> 管理输入(AVCaptureInput)和输出(AVCaptureOutput)流，包含开启和停止会话方法。</li>
<li><code>AVCaptureDeviceInput</code> 是AVCaptureInput的子类,可以作为输入捕获会话，用AVCaptureDevice实例初始化。</li>
<li><code>AVCaptureDevice</code> 代表了物理捕获设备如:摄像机。用于配置等底层硬件设置相机的自动对焦模式。</li>
<li><code>AVCaptureMetadataOutput</code> 是AVCaptureOutput的子类，处理输出捕获会话。捕获的对象传递给一个委托实现AVCaptureMetadataOutputObjectsDelegate协议。协议方法在指定的派发队列（dispatch queue）上执行。</li>
<li><code>AVCaptureVideoPreviewLayer</code>CALayer的一个子类，显示捕获到的相机输出流。</li>
</ul>


<p>下面看下实现过程如下：</p>

<p><strong>Step1:</strong>需要导入：AVFoundation Framework 包含头文件：</p>

<pre><code>#import &lt;AVFoundation/AVFoundation.h&gt;
</code></pre>

<p><strong>Step2:设置捕获会话</strong></p>

<p>设置 AVCaptureSession 和 AVCaptureVideoPreviewLayer 成员</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'>    <span class="cp">#import &lt;AVFoundation/AVFoundation.h&gt;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">kScanQRCodeQueueName</span> <span class="o">=</span> <span class="s">&quot;ScanQRCodeQueue&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">@interface</span> <span class="nc">ViewController</span> <span class="p">()</span> <span class="o">&lt;</span><span class="bp">AVCaptureMetadataOutputObjectsDelegate</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="p">.....</span>
</span><span class='line'>    <span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">)</span> <span class="bp">AVCaptureSession</span> <span class="o">*</span><span class="n">captureSession</span><span class="p">;</span>
</span><span class='line'>    <span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">)</span> <span class="bp">AVCaptureVideoPreviewLayer</span> <span class="o">*</span><span class="n">videoPreviewLayer</span><span class="p">;</span>
</span><span class='line'>    <span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">)</span> <span class="kt">BOOL</span> <span class="n">lastResult</span><span class="p">;</span>
</span><span class='line'>    <span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>Step3:创建会话，读取输入流</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'>    <span class="o">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="n">startReading</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 获取 AVCaptureDevice 实例</span>
</span><span class='line'>        <span class="bp">NSError</span> <span class="o">*</span> <span class="n">error</span><span class="p">;</span>
</span><span class='line'>        <span class="bp">AVCaptureDevice</span> <span class="o">*</span><span class="n">captureDevice</span> <span class="o">=</span> <span class="p">[</span><span class="bp">AVCaptureDevice</span> <span class="nl">defaultDeviceWithMediaType</span><span class="p">:</span><span class="n">AVMediaTypeVideo</span><span class="p">];</span>
</span><span class='line'>        <span class="c1">// 初始化输入流</span>
</span><span class='line'>        <span class="bp">AVCaptureDeviceInput</span> <span class="o">*</span><span class="n">input</span> <span class="o">=</span> <span class="p">[</span><span class="bp">AVCaptureDeviceInput</span> <span class="nl">deviceInputWithDevice</span><span class="p">:</span><span class="n">captureDevice</span> <span class="nl">error</span><span class="p">:</span><span class="o">&amp;</span><span class="n">error</span><span class="p">];</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">input</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">error</span> <span class="n">localizedDescription</span><span class="p">]);</span>
</span><span class='line'>            <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="c1">// 创建会话</span>
</span><span class='line'>        <span class="n">_captureSession</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">AVCaptureSession</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>        <span class="c1">// 添加输入流</span>
</span><span class='line'>        <span class="p">[</span><span class="n">_captureSession</span> <span class="nl">addInput</span><span class="p">:</span><span class="n">input</span><span class="p">];</span>
</span><span class='line'>        <span class="c1">// 初始化输出流</span>
</span><span class='line'>        <span class="bp">AVCaptureMetadataOutput</span> <span class="o">*</span><span class="n">captureMetadataOutput</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">AVCaptureMetadataOutput</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>        <span class="c1">// 添加输出流</span>
</span><span class='line'>        <span class="p">[</span><span class="n">_captureSession</span> <span class="nl">addOutput</span><span class="p">:</span><span class="n">captureMetadataOutput</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 创建dispatch queue.</span>
</span><span class='line'>        <span class="kt">dispatch_queue_t</span> <span class="n">dispatchQueue</span><span class="p">;</span>
</span><span class='line'>        <span class="n">dispatchQueue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="n">kScanQRCodeQueueName</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>        <span class="p">[</span><span class="n">captureMetadataOutput</span> <span class="nl">setMetadataObjectsDelegate</span><span class="p">:</span><span class="nb">self</span> <span class="nl">queue</span><span class="p">:</span><span class="n">dispatchQueue</span><span class="p">];</span>
</span><span class='line'>        <span class="c1">// 设置元数据类型 AVMetadataObjectTypeQRCode</span>
</span><span class='line'>        <span class="p">[</span><span class="n">captureMetadataOutput</span> <span class="nl">setMetadataObjectTypes</span><span class="p">:[</span><span class="bp">NSArray</span> <span class="nl">arrayWithObject</span><span class="p">:</span><span class="n">AVMetadataObjectTypeQRCode</span><span class="p">]];</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 创建输出对象</span>
</span><span class='line'>        <span class="n">_videoPreviewLayer</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">AVCaptureVideoPreviewLayer</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithSession</span><span class="p">:</span><span class="n">_captureSession</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">_videoPreviewLayer</span> <span class="nl">setVideoGravity</span><span class="p">:</span><span class="n">AVLayerVideoGravityResizeAspectFill</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">_videoPreviewLayer</span> <span class="nl">setFrame</span><span class="p">:</span><span class="n">_sanFrameView</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">bounds</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">_sanFrameView</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer</span><span class="p">:</span><span class="n">_videoPreviewLayer</span><span class="p">];</span>
</span><span class='line'>        <span class="c1">// 开始会话</span>
</span><span class='line'>        <span class="p">[</span><span class="n">_captureSession</span> <span class="n">startRunning</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>Step4:停止读取</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'>    <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">stopReading</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 停止会话</span>
</span><span class='line'>        <span class="p">[</span><span class="n">_captureSession</span> <span class="n">stopRunning</span><span class="p">];</span>
</span><span class='line'>        <span class="n">_captureSession</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p><strong>Step5:获取捕获数据</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="p">-(</span><span class="kt">void</span><span class="p">)</span><span class="nf">captureOutput:</span><span class="p">(</span><span class="bp">AVCaptureOutput</span> <span class="o">*</span><span class="p">)</span><span class="nv">captureOutput</span> <span class="nf">didOutputMetadataObjects:</span><span class="p">(</span><span class="bp">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nv">metadataObjects</span>
</span><span class='line'>  <span class="nf">fromConnection:</span><span class="p">(</span><span class="bp">AVCaptureConnection</span> <span class="o">*</span><span class="p">)</span><span class="nv">connection</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">metadataObjects</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="o">&amp;&amp;</span> <span class="p">[</span><span class="n">metadataObjects</span> <span class="n">count</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="bp">AVMetadataMachineReadableCodeObject</span> <span class="o">*</span><span class="n">metadataObj</span> <span class="o">=</span> <span class="p">[</span><span class="n">metadataObjects</span> <span class="nl">objectAtIndex</span><span class="p">:</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'>        <span class="bp">NSString</span> <span class="o">*</span><span class="n">result</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">([[</span><span class="n">metadataObj</span> <span class="n">type</span><span class="p">]</span> <span class="nl">isEqualToString</span><span class="p">:</span><span class="n">AVMetadataObjectTypeQRCode</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">result</span> <span class="o">=</span> <span class="n">metadataObj</span><span class="p">.</span><span class="n">stringValue</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;不是二维码&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span> <span class="nl">performSelectorOnMainThread</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">reportScanResult</span><span class="p">:)</span> <span class="nl">withObject</span><span class="p">:</span><span class="n">result</span> <span class="nl">waitUntilDone</span><span class="p">:</span><span class="nb">NO</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>Step6:处理结果</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'>  <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">reportScanResult</span><span class="p">:(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">result</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="p">[</span><span class="nb">self</span> <span class="n">stopReading</span><span class="p">];</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_lastResult</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">return</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="n">_lastResut</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>      <span class="bp">UIAlertView</span> <span class="o">*</span><span class="n">alert</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIAlertView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTitle</span><span class="p">:</span><span class="s">@&quot;二维码扫描&quot;</span>
</span><span class='line'>                                                      <span class="nl">message</span><span class="p">:</span><span class="n">result</span>
</span><span class='line'>                                                     <span class="nl">delegate</span><span class="p">:</span><span class="nb">nil</span>
</span><span class='line'>                                            <span class="nl">cancelButtonTitle</span><span class="p">:</span><span class="s">@&quot;取消&quot;</span>
</span><span class='line'>                                            <span class="nl">otherButtonTitles</span><span class="p">:</span> <span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>      <span class="p">[</span><span class="n">alert</span> <span class="n">show</span><span class="p">];</span>
</span><span class='line'>      <span class="c1">// 以下处理了结果，继续下次扫描</span>
</span><span class='line'>      <span class="n">_lastResult</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>以上基本就是二维码的获取流程，和扫一扫二维码伴随的就是开启系统照明，这个比较简单，也是利用 <code>AVCaptureDevice</code>,请看如下实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'>  <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">systemLightSwitch</span><span class="p">:(</span><span class="kt">BOOL</span><span class="p">)</span><span class="n">open</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="bp">AVCaptureDevice</span> <span class="o">*</span><span class="n">device</span> <span class="o">=</span> <span class="p">[</span><span class="bp">AVCaptureDevice</span> <span class="nl">defaultDeviceWithMediaType</span><span class="p">:</span><span class="n">AVMediaTypeVideo</span><span class="p">];</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">([</span><span class="n">device</span> <span class="n">hasTorch</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>          <span class="p">[</span><span class="n">device</span> <span class="nl">lockForConfiguration</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>          <span class="k">if</span> <span class="p">(</span><span class="n">open</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>              <span class="p">[</span><span class="n">device</span> <span class="nl">setTorchMode</span><span class="p">:</span><span class="n">AVCaptureTorchModeOn</span><span class="p">];</span>
</span><span class='line'>          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>              <span class="p">[</span><span class="n">device</span> <span class="nl">setTorchMode</span><span class="p">:</span><span class="n">AVCaptureTorchModeOff</span><span class="p">];</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>          <span class="p">[</span><span class="n">device</span> <span class="n">unlockForConfiguration</span><span class="p">];</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>以上就是本文介绍的大部分内容，详细代码请看demo <a href="https://github.com/strivingboy/scan_qrcode_demo.git">scan_qrcode_deomo</a></p>

<p>实现过程中遇到一下两个问题：</p>

<p>1、扫描一个二维码，输出流回重复调用，代理方法头文件介绍：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'>   <span class="cm">/*!</span>
</span><span class='line'><span class="cm">  @method captureOutput:didOutputMetadataObjects:fromConnection:</span>
</span><span class='line'><span class="cm">  .....  </span>
</span><span class='line'><span class="cm">  @discussion</span>
</span><span class='line'><span class="cm">     Delegates receive this message whenever the output captures and emits new objects, as specified by</span>
</span><span class='line'><span class="cm">     its metadataObjectTypes property. Delegates can use the provided objects in conjunction with other APIs</span>
</span><span class='line'><span class="cm">     for further processing. This method will be called on the dispatch queue specified by the output&#39;s</span>
</span><span class='line'><span class="cm">     metadataObjectsCallbackQueue property. **This method may be called frequently** so it must be efficient to </span>
</span><span class='line'><span class="cm">     prevent capture performance problems, including dropped metadata objects.</span>
</span><span class='line'><span class="cm"> </span>
</span><span class='line'><span class="cm">     Clients that need to reference metadata objects outside of the scope of this method must retain them and</span>
</span><span class='line'><span class="cm">     then release them when they are finished with them.</span>
</span><span class='line'><span class="cm"> */</span>
</span></code></pre></td></tr></table></div></figure>


<p>代理方法会频繁调用，我暂且用一个标记（@property (nonatomic) BOOL lastResult）表示是否是第一次扫描成功，来处理。</p>

<p>2、AVFoundation
该库不能扫描相册中的二维码图片，不知为啥苹果没有支持，有知道实现的麻烦告诉我哈。</p>

<p><strong> 参考链接 </strong></p>

<ul>
<li><p><u><a href="http://useyourloaf.com/blog/2014/05/13/reading-qr-codes.html">http://useyourloaf.com/blog/2014/05/13/reading-qr-codes.html</a></u></p></li>
<li><p><u><a href="http://www.appcoda.com/qr-code-ios-programming-tutorial/">http://www.appcoda.com/qr-code-ios-programming-tutorial/</a> </u></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[更好的git log]]></title>
    <link href="http://strivingboy.github.io/blog/2014/09/29/better-git-log/"/>
    <updated>2014-09-29T11:05:41+08:00</updated>
    <id>http://strivingboy.github.io/blog/2014/09/29/better-git-log</id>
    <content type="html"><![CDATA[<p><code>git log</code>对于使用git的&#8221;码农们&#8221;一定非常熟悉，如：</p>

<p> git log  命令是查看全部提交日志</p>

<p> git log -2  查看最近2次的提交日志</p>

<p> git log -p  查看历史纪录以来哪几行被修改</p>

<p> git log &ndash;oneline 查看历史提交日志，单行显示</p>

<!--more-->


<p>以上是我们经常使用过的命令，接下来将谈谈如何更好的使用git log来解决使用过程中遇到的需求：（大家有木有遇到呢&hellip;）</p>

<p><strong>提交历史搜索</strong></p>

<p><code>git log --author="&lt;pattern&gt;"</code></p>

<p>根据提交作者，搜索提交历史 pattern 可以是字符串或这则表达式</p>

<p><code>git log --grep="&lt;pattern&gt;"</code></p>

<p>搜索提交历史 同上pattern 可以是字符串或这则表达式</p>

<p><strong>更清楚的显示单行提交历史</strong></p>

<p><code>git log --pretty=online</code> 显示如下：</p>

<p><img src="http://strivingboy.github.com/images/2014-09-29-oneline.png" alt="git log --pretty=online" /></p>

<p>如何图形化显示更清晰的提交历史呢？</p>

<p><code>git log --graph --decorate --pretty=oneline --abbrev-commit --all</code></p>

<p><img src="http://strivingboy.github.com/images/2014-09-29-lola.png" alt="git log lola" /></p>

<p>能不能再清楚点呢？比如：显示提交时间、作者&hellip;..当然可以啦</p>

<p><code>git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit</code></p>

<p><img src="http://strivingboy.github.com/images/2014-09-29-lg.png" alt="git log lola" /></p>

<p>是不是漂亮了很多，每次打完包我们都回写下change log, 之前每次都是根据git log 复制后编辑，汗&hellip;这体力活，有了上面的命令轻松修改下：</p>

<p><code>git log --pretty=format:'%s  %C(bold blue)(%an)%Creset' --abbrev-commit</code></p>

<p><img src="http://strivingboy.github.com/images/2014-09-29-changelog.png" alt="git log lola" /></p>

<p>上面的命令这么长，每次敲岂不累死（前提是要记得住，哈哈）我们可以使用linux 下的 alias,详见：<u><a href="http://en.wikipedia.org/wiki/Alias_">http://en.wikipedia.org/wiki/Alias_</a>(command) </u></p>

<p><code>git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</code></p>

<p>现在你每次在终端输入git lg 就可以啦. 关于git 别名，可以参见：</p>

<p><strong><a href="http://strivingboy.github.com/blog/2014/09/03/git-aliase/">让Git命令更简单（Git alias)</a></strong></p>

<p><strong> 参考链接 </strong></p>

<ul>
<li><p><u><a href="https://www.kernel.org/pub/software/scm/git/docs/git-log.html">https://www.kernel.org/pub/software/scm/git/docs/git-log.html</a> </u></p></li>
<li><p><u><a href="https://coderwall.com/p/euwpig">https://coderwall.com/p/euwpig</a> </u></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ios 8 Touch ID 使用]]></title>
    <link href="http://strivingboy.github.io/blog/2014/09/23/touchid-use/"/>
    <updated>2014-09-23T13:14:06+08:00</updated>
    <id>http://strivingboy.github.io/blog/2014/09/23/touchid-use</id>
    <content type="html"><![CDATA[<h2>Touch ID 介绍</h2>

<p>参考：<u><a href="http://www.imore.com/touch-id-ios-8-explained">http://www.imore.com/touch-id-ios-8-explained</a> </u></p>

<h2>Touch ID API</h2>

<p>前提：只有在装有iOS8的真机设备才能编译通过。</p>

<p><strong>Step1).</strong> 使用Touch ID API,首先需要导入:<code>LocalAuthentication.framework</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="cp">#import &lt;LocalAuthentication/LAContext.h&gt; </span>
</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p><strong>Step2).</strong> 使用API，我们需要创建一个Authentication Context</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="n">LAContext</span> <span class="o">*</span><span class="n">myContext</span> <span class="o">=</span> <span class="p">[[</span><span class="n">LAContext</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>Step3).</strong> 检查当前Touch ID 是否可用,设备没有TouchID或者TouchID未开启返回false，有TouchID并开启返回true.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'>  <span class="o">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nl">canEvaluatePolicy</span><span class="p">:(</span><span class="n">LAPolicy</span><span class="p">)</span><span class="n">policy</span> <span class="nl">error</span><span class="p">:(</span><span class="bp">NSError</span> <span class="o">*</span> <span class="k">__autoreleasing</span> <span class="o">*</span><span class="p">)</span><span class="n">error</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>Step4).</strong> 调用显示验证界面</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'>  <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">evaluatePolicy</span><span class="p">:(</span><span class="n">LAPolicy</span><span class="p">)</span><span class="n">policy</span>
</span><span class='line'>         <span class="nl">localizedReason</span><span class="p">:(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">localizedReason</span>
</span><span class='line'>                     <span class="nl">reply</span><span class="p">:(</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">BOOL</span> <span class="n">success</span><span class="p">,</span> <span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">))</span><span class="n">reply</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>localizedReason：根据官方文档必须提供.</p>

<p>reply:验证成功 success == YES, 否则返回error,根据<strong>error.code</strong>可以得到具体的原因.</p>

<p>在<code>&lt;LocalAuthentication/LAError.h&gt;</code>头文件中可以看到如下定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'>  <span class="k">typedef</span> <span class="nf">NS_ENUM</span><span class="p">(</span><span class="bp">NSInteger</span><span class="p">,</span> <span class="n">LAError</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="c1">/// Authentication was not successful, because user failed to provide valid credentials.</span>
</span><span class='line'>      <span class="n">LAErrorAuthenticationFailed</span> <span class="o">=</span> <span class="n">kLAErrorAuthenticationFailed</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">/// Authentication was canceled by user (e.g. tapped Cancel button).</span>
</span><span class='line'>      <span class="n">LAErrorUserCancel</span>           <span class="o">=</span> <span class="n">kLAErrorUserCancel</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">/// Authentication was canceled, because the user tapped the fallback button (Enter Password).</span>
</span><span class='line'>      <span class="n">LAErrorUserFallback</span>         <span class="o">=</span> <span class="n">kLAErrorUserFallback</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">/// Authentication was canceled by system (e.g. another application went to foreground).</span>
</span><span class='line'>      <span class="n">LAErrorSystemCancel</span>         <span class="o">=</span> <span class="n">kLAErrorSystemCancel</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">/// Authentication could not start, because passcode is not set on the device.</span>
</span><span class='line'>      <span class="n">LAErrorPasscodeNotSet</span>       <span class="o">=</span> <span class="n">kLAErrorPasscodeNotSet</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">/// Authentication could not start, because Touch ID is not available on the device.</span>
</span><span class='line'>      <span class="n">LAErrorTouchIDNotAvailable</span>  <span class="o">=</span> <span class="n">kLAErrorTouchIDNotAvailable</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">/// Authentication could not start, because Touch ID has no enrolled fingers.</span>
</span><span class='line'>      <span class="n">LAErrorTouchIDNotEnrolled</span>   <span class="o">=</span> <span class="n">kLAErrorTouchIDNotEnrolled</span><span class="p">,</span>
</span><span class='line'>  <span class="p">}</span> <span class="n">NS_ENUM_AVAILABLE</span><span class="p">(</span><span class="mi">10</span><span class="n">_10</span><span class="p">,</span> <span class="mi">8</span><span class="n">_0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Touch ID API 简单封装Demo</h2>

<p><strong>TouchIdUtil.h</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'>    <span class="k">typedef</span> <span class="nf">NS_ENUM</span><span class="p">(</span><span class="bp">NSInteger</span><span class="p">,</span> <span class="n">TouchIdEvaluateResult</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">kTouchIdEvaluateResultSuccess</span><span class="p">,</span>   <span class="c1">// 验证成功</span>
</span><span class='line'>        <span class="n">kTouchIdEvaluateResultFailed</span><span class="p">,</span>    <span class="c1">// 验证失败</span>
</span><span class='line'>        <span class="n">kTouchIdEvaluateResultCancel</span><span class="p">,</span>    <span class="c1">// 点击取消按钮</span>
</span><span class='line'>        <span class="n">kTouchIdEvaluateResultFallback</span><span class="p">,</span>  <span class="c1">// 点击回退按钮</span>
</span><span class='line'>        <span class="n">kTouchIdEvaluateResultOther</span>      <span class="c1">// 未知结果</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">typedef</span> <span class="nf">void</span><span class="p">(</span><span class="o">^</span><span class="n">TouchIdEvaluateCallback</span><span class="p">)(</span><span class="n">TouchIdEvaluateResult</span> <span class="n">result</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">@interface</span> <span class="nc">TouchIdUtil</span> : <span class="bp">NSObject</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="n">sharedInstance</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Touch Id 是否开启或设置</span>
</span><span class='line'>    <span class="o">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="n">canEvaluatePolicy</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Touch Id 验证 callback回调已经抛到了主线程</span>
</span><span class='line'>    <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">evaluatePolicy</span><span class="p">:(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">localizedReasion</span>
</span><span class='line'>             <span class="nl">fallbackTitle</span><span class="p">:(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">title</span>
</span><span class='line'>                  <span class="nl">callback</span><span class="p">:(</span><span class="n">TouchIdEvaluateCallback</span><span class="p">)</span><span class="n">cb</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>TouchIdUtil.m</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="cp">#import &quot;TouchIdUtil.h&quot;</span>
</span><span class='line'><span class="cp">#import &lt;LocalAuthentication/LocalAuthentication.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">TouchIdUtil</span>
</span><span class='line'>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">sharedInstance</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="n">TouchIdUtil</span><span class="o">*</span> <span class="n">instance</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="k">static</span> <span class="kt">dispatch_once_t</span> <span class="n">onceToken</span><span class="p">;</span>
</span><span class='line'>    <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">onceToken</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">instance</span> <span class="o">=</span> <span class="p">[[</span><span class="n">TouchIdUtil</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">canEvaluatePolicy</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">LAContext</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="p">[[</span><span class="n">LAContext</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">context</span> <span class="nl">canEvaluatePolicy</span><span class="p">:</span> <span class="n">LAPolicyDeviceOwnerAuthenticationWithBiometrics</span> <span class="nl">error</span><span class="p">:</span><span class="o">&amp;</span><span class="n">error</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">evaluatePolicy:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">localizedReasion</span>
</span><span class='line'>         <span class="nf">fallbackTitle:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">title</span>
</span><span class='line'>              <span class="nf">callback:</span><span class="p">(</span><span class="n">TouchIdEvaluateCallback</span><span class="p">)</span><span class="nv">cb</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">LAContext</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="p">[[</span><span class="n">LAContext</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">title</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">context</span><span class="p">.</span><span class="n">localizedFallbackTitle</span> <span class="o">=</span> <span class="n">title</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">NSString</span> <span class="o">*</span><span class="n">myLocalizedReasonString</span> <span class="o">=</span> <span class="n">localizedReasion</span><span class="p">;</span>
</span><span class='line'>    <span class="k">__weak</span> <span class="k">typeof</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="n">weakSelf</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">context</span> <span class="nl">evaluatePolicy</span><span class="p">:</span><span class="n">LAPolicyDeviceOwnerAuthenticationWithBiometrics</span>
</span><span class='line'>             <span class="nl">localizedReason</span><span class="p">:</span><span class="n">myLocalizedReasonString</span>
</span><span class='line'>                       <span class="nl">reply</span><span class="p">:</span>
</span><span class='line'>     <span class="o">^</span><span class="p">(</span><span class="kt">BOOL</span> <span class="n">succes</span><span class="p">,</span> <span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>         <span class="k">if</span> <span class="p">(</span><span class="n">succes</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>             <span class="p">[[</span><span class="n">weakSelf</span> <span class="k">class</span><span class="p">]</span> <span class="nl">reportResultOnUI</span><span class="p">:</span><span class="n">kTouchIdEvaluateResultSuccess</span> <span class="nl">callback</span><span class="p">:</span><span class="n">cb</span><span class="p">];</span>
</span><span class='line'>         <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>             <span class="k">switch</span> <span class="p">(</span><span class="n">error</span><span class="p">.</span><span class="n">code</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                 <span class="k">case</span> <span class="nl">LAErrorAuthenticationFailed</span><span class="p">:</span>
</span><span class='line'>                     <span class="p">[[</span><span class="n">weakSelf</span> <span class="k">class</span><span class="p">]</span> <span class="nl">reportResultOnUI</span><span class="p">:</span><span class="n">kTouchIdEvaluateResultFailed</span> <span class="nl">callback</span><span class="p">:</span><span class="n">cb</span><span class="p">];</span>
</span><span class='line'>                     <span class="k">break</span><span class="p">;</span>
</span><span class='line'>                 <span class="k">case</span> <span class="nl">LAErrorUserCancel</span><span class="p">:</span>
</span><span class='line'>                     <span class="p">[[</span><span class="n">weakSelf</span> <span class="k">class</span><span class="p">]</span> <span class="nl">reportResultOnUI</span><span class="p">:</span><span class="n">kTouchIdEvaluateResultCancel</span> <span class="nl">callback</span><span class="p">:</span><span class="n">cb</span><span class="p">];</span>
</span><span class='line'>                     <span class="k">break</span><span class="p">;</span>
</span><span class='line'>                 <span class="k">case</span> <span class="nl">LAErrorUserFallback</span><span class="p">:</span>
</span><span class='line'>                     <span class="p">[[</span><span class="n">weakSelf</span> <span class="k">class</span><span class="p">]</span> <span class="nl">reportResultOnUI</span><span class="p">:</span><span class="n">kTouchIdEvaluateResultFallback</span> <span class="nl">callback</span><span class="p">:</span><span class="n">cb</span><span class="p">];</span>
</span><span class='line'>                     <span class="k">break</span><span class="p">;</span>
</span><span class='line'>                 <span class="k">default</span><span class="o">:</span>
</span><span class='line'>                     <span class="p">[[</span><span class="n">weakSelf</span> <span class="k">class</span><span class="p">]</span> <span class="nl">reportResultOnUI</span><span class="p">:</span><span class="n">kTouchIdEvaluateResultOther</span> <span class="nl">callback</span><span class="p">:</span><span class="n">cb</span><span class="p">];</span>
</span><span class='line'>                     <span class="k">break</span><span class="p">;</span>
</span><span class='line'>             <span class="p">}</span>
</span><span class='line'>         <span class="p">}</span>
</span><span class='line'>     <span class="p">}];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">reportResultOnUI:</span><span class="p">(</span><span class="n">TouchIdEvaluateResult</span><span class="p">)</span><span class="nv">result</span> <span class="nf">callback:</span><span class="p">(</span><span class="n">TouchIdEvaluateCallback</span><span class="p">)</span><span class="nv">cb</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">cb</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>
<strong> 问题总结 </strong></p>

<p>1.指纹识别3次错误会弹出系统“输入密码”数字键盘，而且这3次错误机会是系统所有应用共享</p>

<p>2.不要在 <code>evaluatePolicy:</code>方法中调用 <code>canEvaluatePolicy</code> <code>&lt;LocalAuthentication/LAContext.h&gt;</code>中有说明</p>

<p><strong> Demo 见：<a href="https://github.com/strivingboy/touchid.git">TouchIdTest</a></strong></p>

<p><strong> 参考链接 </strong></p>

<ul>
<li><p><u><a href="https://developer.apple.com/library/ios/documentation/LocalAuthentication/Reference/LAContext_Class/index.html#//apple_ref/occ/cl/LAContext">https://developer.apple.com/library/ios/documentation/LocalAuthentication/Reference/LAContext_Class/index.html#//apple_ref/occ/cl/LAContext</a> </u></p></li>
<li><p><u><a href="http://hayageek.com/ios-touch-id-authentication-api/">http://hayageek.com/ios-touch-id-authentication-api/</a> </u></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[让Git命令更简单（Git alias）]]></title>
    <link href="http://strivingboy.github.io/blog/2014/09/07/git-aliase/"/>
    <updated>2014-09-07T11:10:44+08:00</updated>
    <id>http://strivingboy.github.io/blog/2014/09/07/git-aliase</id>
    <content type="html"><![CDATA[<p>简单使用 git 命令的方式莫过于添加别名了，alias时linux下一个常用命令详见：<u><a href="http://en.wikipedia.org/wiki/Alias_">http://en.wikipedia.org/wiki/Alias_</a>(command) </u></p>

<p><strong>如何添加别名</strong></p>

<p>假设我们想用 <code>git ci</code>代替<code>git commit</code>, 我们可以添加如下命令到 <code>~/.gitconfig</code> 文件中</p>

<pre><code>［alias］
    ci = commit
</code></pre>

<p>如果不习惯手动编辑 config 文件，也可以使用命令 <code>git config alias.ci commit</code>来代替，如果想在自己机器的任何地方都使用改别名，则可添加 <code>--global</code> 标记</p>

<pre><code>git config --global alias.ci commit
</code></pre>

<!--more-->


<p><strong>常用别名</strong></p>

<pre><code>[alias]
  st = status
  ci = commit
  br = branch
  co = checkout
  df = diff
  ad=add
  cp = cherry-pick
  lg = log -p
</code></pre>

<p><strong>其他别名</strong></p>

<p>1.初始化git仓库</p>

<p><code>this = !git init &amp;&amp; git add . &amp;&amp; git commit -m \"initial commit\"</code></p>

<p>2.暂存</p>

<p><code>sl = stash list</code></p>

<p><code>sa = stash apply</code></p>

<p><code>ss = stash save</code></p>

<p>2.删除已经删除的文件</p>

<p><code>rd = git rm $(git ls-files --deleted) </code></p>

<p>3.清空未暂存的文件</p>

<p><code>cd = git clean -df</code></p>

<p>4.撤销本地所有修改</p>

<p><code>cl = git checkout .</code></p>

<p>5.列出所有别名</p>

<p><code>alias = config --get-regexp 'alias.*'</code></p>

<p>以上是我的常用git 别名，其他有意思的请在下面评论哈&hellip;..</p>

<p><strong> 参考链接 </strong></p>

<ul>
<li><u><a href="http://en.wikipedia.org/wiki/Alias_">http://en.wikipedia.org/wiki/Alias_</a>(command) </u></li>
<li><u><a href="http://git-scm.com/docs/">http://git-scm.com/docs/</a> </u></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git 基础(三)]]></title>
    <link href="http://strivingboy.github.io/blog/2014/08/17/git-ji-chu-san/"/>
    <updated>2014-08-17T19:34:55+08:00</updated>
    <id>http://strivingboy.github.io/blog/2014/08/17/git-ji-chu-san</id>
    <content type="html"><![CDATA[<p>前两篇文章介绍了git的常用命令，基本已经能够满足我们的日常使用，这篇将谈谈使用过程中疑惑的地方，比如：何时使用<code>git rebase</code>何时使用<code>git merge</code>等</p>

<p><strong>1、Merging VS Rebasing</strong></p>

<p><code>git merge</code> 和 <code>git rebase</code> 命令都是用来将一个分支合并到另一个分支，只是用不同的方式罢了。下面看下它们的不同：</p>

<!--more-->


<p><strong>Case:</strong></p>

<p>当你开发一个独立的功能，为此建立了一个特性分支（假设是feature_branch）提交代码，其他团队成员在master分支上提交，结果必然有一个分叉的提交历史,现在假设你发现master分支上新的提交和你开发的功能有关系，为了将这些新的提交合并到feature_branch,于是就有两种选择：merging 或 rebasing</p>

<p><strong>Merging</strong></p>

<p>最简单的操作就是将master分支合并到feature_branch，如下：</p>

<pre><code>git checkout feature_branch
git merge master
</code></pre>

<p>或者</p>

<pre><code>git merge master feature_branch
</code></pre>

<p>最终会在feature_branch上创建一个新的合并提交记录。</p>

<p><code>merging</code> 是一个友好的命令，因为它是一个没有破坏性的操作，现有的分支不会有任何形式的改变，因此也就避免了<code>rebasing</code> 一些潜在的缺陷, 相反，这就意味着每一次<code>merging</code>都会在feature_branch会遗留一次额外的提交，当master分支非常活跃时，这将导致feature_branch分支的历史记录初步变大，这时查看工程历史记录，就会发现各种分叉，很难理解。</p>

<p><strong>Rebasing</strong></p>

<p>作为<code>merging</code>的替代方法，我们也可以将feature_branch分支 rebase到master分支，命令如下：</p>

<pre><code>git checkout feature_branch
git rebase master
</code></pre>

<p>结果将feature_branch上所有提交移动到了master分支的最前面，很高效，但与 merge 不同的是 rebase会重写工程提交历史，就像是在master上重新提交了一遍一样,而不是想mege那样创建一个新的合并提交记录。</p>

<p><code>rebasing</code>最大的优点便是它可以得到一个很清晰的历史记录，首先，它避免了<code>merging</code>产生的那个不必要的提交记录，其次，<code>rebasing</code>的结果是一个完美的线型提交历史，可以很清楚的看到工程的变化。当然：<code>rebasing</code>也存在潜在的问题：1、安全性（在下面的rebase黄金法则中介绍） 2、可追溯性，即：<code>rebasing</code>或失去 <code>merging</code>创建的合并记录，从而无法查看合并记录点。</p>

<p><strong>Rebasing黄金法则</strong></p>

<p>理解了<code>rebasing</code>的使用，下来就是何时使用:<code>The golden rule is to never use it on public branches.</code></p>

<p>举个例子：
假设你讲 master 分支rebase 到 feature_brauch分支,结果将master上所有提交移动到feature_brauch的最前面，问题是：这次合并操作只影响feature_brauch分支，所有其他开发这依然在original master分支上工作，由于<code>rebasing</code>是重写提交历史，git 会认为所有历史提交已经与其他开发者提交的不同，同步这两个分支唯一的办法是将feature_brauch分支又<code>merging</code>到master分支，结果是两次提交集合中大部分包含了相同的修改，不用说,这是一个非常混乱的局面。因此，当执行<code>rebasing</code>操作时，时常问下自己：<code>是不是有其他人在关注改分支？</code>如果是，则考虑其它方式，否则则可以安全使用<code>rebasing</code>。</p>

<p><strong>2、Reset, Checkout, and Revert</strong></p>

<p><code>git reset</code>、<code>git checkout</code>和<code>git revert</code>都是用来撤销对代码仓库的各种修改，前两个命令可以操作提交或单个文件，他们如此相似，在某种场合下容易混谣，下面我们将谈谈它们的区别。</p>

<p>我们都知道git 有三个主要的组件：1、工作区（Working Directory）2、暂存区（Staged Snapshot）3、提交历史(Commit History),理解这三个组件就不难掌握<code>git reset</code>、<code>git checkout</code>和<code>git revert</code>的区别，</p>

<p><code>Reset</code>:命令可以撤销当前分支的某些提交，如：</p>

<pre><code>git checkout feature_branch
git reset HEAD^2
</code></pre>

<p>上面的命令将当前分支回退了两次提交，<code>Reset</code>命令对于想撤销某些提交（前提是当前分支只有自己提交）时非常方便，<code>Reset</code>命令有一下标记：</p>

<ul>
<li>&ndash;soft:使用该标记不会影响暂存区和工作区</li>
<li>&ndash;mixed:使用该标记后，暂存区会更新到了指定的提交，工作区不影响，该标记是默认的</li>
<li>&ndash;hard:暂存区和工作区均更新到指定提交</li>
</ul>


<p><em>git reset &ndash;mixed HEAD</em> 会将本地暂存的修改从暂存区取出来，如果想彻底删除未提交的修改，可以使用<em>git reset &ndash;hard HEAD</em> （危险：本地修改将不会恢复了哦）这是<code>Reset</code>常用的两种方式。</p>

<p><code>Checkout</code>:应该非常熟悉了，首先就是切换分支：</p>

<pre><code>git checkout master
</code></pre>

<p>git 内部会将HEAD游标移动到master分支，并且更新工作区，因为它会重写本地修改，所以git强制我们在<code>Checkout</code>之前去提交或暂存工作区中的修改。</p>

<pre><code>git checkout .
</code></pre>

<p>注意该命令危险！它和 <em>git reset &ndash;hard HEAD</em> 类似，会彻底删除未提交的修改,不可恢复。</p>

<p><code>Revert</code>:命令是用一个新的提交来撤销某次历史提交，不会重写提交历史，是安全可恢复的。因此可用于公开提交的分支，这点与<code>Reset</code>不同，<code>Reset</code>仅用于私有特性分支。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git 使用基础(二)]]></title>
    <link href="http://strivingboy.github.io/blog/2014/08/09/git-ji-chu-er/"/>
    <updated>2014-08-09T23:09:56+08:00</updated>
    <id>http://strivingboy.github.io/blog/2014/08/09/git-ji-chu-er</id>
    <content type="html"><![CDATA[<p><strong>git checkout</strong></p>

<p><code>git checkout</code> 命令提供三种功能：1、查看文件历史修改 2、切换到某次提交（或某次提交的特定文件） 3、切换分支</p>

<p>用法：</p>

<pre><code>git checkout master
</code></pre>

<p>从当前分支切换到master分支</p>

<pre><code>git checkout &lt;commit&gt; &lt;file&gt;
</code></pre>

<p>将本地文件file 更新到 commit 次提交</p>

<!--more-->


<p>例子：</p>

<pre><code>git log --oneline 查看下历史提交如下：

```
ad90c97 modify link
9de0669 add oneline.png
b83c889 modify test.txt
```

git checkout ad90c97 查看修改内容

git checkout b83c889 test.txt 查看对test.txt 文件的修改
</code></pre>

<p><strong>git revert</strong></p>

<p><code>git revert</code> 命令用来撤销历史中的某次提交，并且不会撤销其后面的提交历史</p>

<p>用法：</p>

<pre><code>git revert &lt;commit&gt;
</code></pre>

<p>撤销 commit 次提交</p>

<p><strong>git reset</strong></p>

<p><code>git reset</code> 命令用来撤销历史中的某次提交，也会撤销其后面的提交历史以</p>

<p>用法：</p>

<pre><code>git revert &lt;commit&gt;
</code></pre>

<p>撤销 commit 次提交</p>

<pre><code>git revert --hard &lt;commit&gt;
</code></pre>

<p>将当前分之会退到 commit 提交，并且会撤销本地未提交的修改（不安全）</p>

<p><strong>git clean</strong></p>

<p><code>git clean</code> 命令用来移除本地未暂存的文件，相当于<code>git reset --hard</code></p>

<p>用法：</p>

<pre><code>git clean -df
</code></pre>

<p>移除本地未暂存的修改以及文件</p>

<p><strong>git rebase</strong></p>

<p><code>git rebase</code> 命令用来将一个分支移动到某个分支（如B分支），在B分支上作为最新的提交（结果相当于 git merge）</p>

<p>用法：</p>

<pre><code>git rebase &lt;base&gt;
</code></pre>

<p>将当前分支移动到base分支</p>

<p><strong>git merge</strong></p>

<p><code>git merge</code> 命令用来将一个分支合并到某个分支,合并的结果作为一次新的提交</p>

<p>用法：</p>

<pre><code>git merge &lt;branch&gt;
</code></pre>

<p>合并branch分支合并到当前分支，和<code>git rebase</code>的区别以及各自优缺点见这里: <strong><a href="http://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E8%A1%8D%E5%90%88">git rebase vs git merge</a></strong></p>

<p><strong>git fetch</strong></p>

<p><code>git fetch</code> 命令用来获取远端仓库最新代码到本地,不会自动合并（相当于开了一个tmp分支）</p>

<p>用法：</p>

<pre><code>git fetch &lt;remote&gt; 或 git fetch &lt;remote&gt; &lt;branch&gt;
</code></pre>

<p><strong>git pull</strong></p>

<p><code>git pull</code> 命令用来获取远端仓库最新代码并且和本地代码自动合并</p>

<p>用法：</p>

<pre><code>git pull &lt;remote&gt; 
</code></pre>

<p>相当于：git fetch <remote> ＋ git merge origin/<current-branch>.</p>

<pre><code>git pull --rebase &lt;remote&gt;
</code></pre>

<p>相当于：git fetch <remote> + git rebase origin/<current-branch>.</p>

<p>实际上，很多开发者都使用 <code>git pull --rebase</code> git 也提供了对应的配置如下：</p>

<pre><code>git config --global branch.autosetuprebase always
</code></pre>

<p>详细理由见这里： <strong><a href="http://stackoverflow.com/questions/18930527/difference-between-git-pull-and-git-pull-rebase">git pull 和 git pull &ndash;rebase的不同</a></strong></p>

<p><strong>git push</strong></p>

<p><code>git push</code> 命令用来将本地提交推送到远程仓库</p>

<p>用法：</p>

<pre><code>git push &lt;remote&gt; &lt;branch&gt;
</code></pre>

<p><code>git push &lt;remote&gt; --tags</code> 将本地标签推送到远端，默认标签不会自动推送</p>

<p><strong>git remote</strong></p>

<p><code>git remote</code> 命令用来列出每个远程库的简短名字</p>

<p>用法：</p>

<pre><code>git remote
</code></pre>

<p>要查看当前配置有哪些远程仓库，可以用<code>git remote</code>命令，它会列出每个远程库的简短名字。在克隆完某个项目后，至少可以看到一个名为 origin 的远程库，Git 默认使用这个名字来标识你所克隆的原始仓库</p>

<pre><code>git remote -v 
</code></pre>

<p>结果如下：</p>

<pre><code>origin  https://github.com/strivingboy/strivingboy.github.com.git (fetch)
origin  https://github.com/strivingboy/strivingboy.github.com.git (push)
</code></pre>

<p>显示对应的克隆地址</p>

<pre><code>git remote add &lt;shortname&gt; &lt;url&gt;
</code></pre>

<p>添加一个新的远程仓库，可以指定一个简单的名字 shortname，以便将来引用</p>

<pre><code>git remote rm &lt;shortname&gt;
</code></pre>

<p>删除远端名为shortname的仓库</p>

<pre><code>git remote rename &lt;old-name&gt; &lt;new-name&gt;
</code></pre>

<p>将远程仓库 old-name 重命名为 new-name</p>

<p>下一篇：<a href="http://strivingboy.github.com/blog/2014/08/17/git-ji-chu-san/">Git 使用基础(三)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git 使用基础(一)]]></title>
    <link href="http://strivingboy.github.io/blog/2014/08/03/git-ji-chu/"/>
    <updated>2014-08-03T10:33:16+08:00</updated>
    <id>http://strivingboy.github.io/blog/2014/08/03/git-ji-chu</id>
    <content type="html"><![CDATA[<p>对于git的学习推荐一下资料：</p>

<ul>
<li>GitPro:<u><a href="http://git-scm.com/book/zh">http://git-scm.com/book/zh</a> </u> 很不错的入门书籍</li>
<li>Git命令在线文档: <u><a href="http://git-scm.com/docs/">http://git-scm.com/docs/</a> </u>非常全面</li>
<li>Git权威指南: <u><a href="http://book.douban.com/subject/6526452/">http://book.douban.com/subject/6526452/</a> </u> 中国人写的比较不错的Git书籍</li>
</ul>


<p>如果不想敲 git 命令来使用 git，推荐一个非常不错的 git 图形画工具:</p>

<p><u> <a href="http://www.sourcetreeapp.com/">http://www.sourcetreeapp.com/</a> </u>  各个平台下都有，更新也非常快</p>

<p>要高效快速的使用git,还是建议学习使用git 命令，使用git 也有一段时间了，也准备开始写写技术博客，于是搭建了自己的github博客，记录下自己的学习以及思考，也方便自己查阅。</p>

<!--more-->


<p>本文参考：<u><a href="https://www.atlassian.com/git/tutorials/setting-up-a-repository">https://www.atlassian.com/git/tutorials/setting-up-a-repository</a> </u></p>

<p><strong>git init</strong></p>

<p><code>git init</code> 命令用来创建一个新的git仓库，git 大部分命令都是再git仓库下运行</p>

<p>用法：</p>

<pre><code>git init
</code></pre>

<p>将当前目录转换为 git 仓库</p>

<pre><code>git init &lt;directory&gt;
</code></pre>

<p>将特定目录转换为 git 仓库</p>

<pre><code>git init --bare 
</code></pre>

<p>初始化一个空的（裸的） git 仓库，它不包含工作目录，并且不能提交编辑和提交修改，该仓库主要用于远端服务器管理代码，保存git历史提交的版本信息，防止冲突。如下说明：</p>

<p>比如:A用户在该目录（就称为远端仓库）下执行git操作，且有两个分支(master 和 branchA)，当前在master分支下。B用户想把自己在本地仓库（就称为本地仓库）的master分支的更新提交到远端仓库的master分支，想当然的使用：</p>

<pre><code>git push origin master:master
</code></pre>

<p>于是乎出现问题：因为远端仓库的A用户正在master的分支上操作，而B又要把更新提交到这个master分支上，当然会出现错误(冲突)。但如果是往远端仓库中空闲的分支上提交还是可以的，比如</p>

<pre><code>git push origin master:branchB 
</code></pre>

<p>还是可以成功的, 解决办法就是使用”git init –bare”方法创建一个所谓的裸仓库,也是最好把远端仓库初始化成bare仓库的原因，服务器上部署git 请参考：<a href="http://git-scm.com/book/zh/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2-Git">服务器上部署 Git</a></p>

<p>例子：</p>

<pre><code>cd path/repo
git init
</code></pre>

<p><strong>git clone</strong></p>

<p><code>git clone</code> 命令用来复制一个已经存在的 git 仓库，相当于 <code>svn checkout</code></p>

<p>用法：</p>

<pre><code>git clone &lt;repo&gt;
</code></pre>

<p>复制远端仓库 repo 到本地机器</p>

<pre><code>git clone &lt;repo&gt; &lt;directory&gt;
</code></pre>

<p>复制远端仓库 repo directory目录到本地机器</p>

<p>例子：</p>

<pre><code>git clone https://example.com/path/project_name.git ~/project/
cd ~/project/project_name
#Start working on the project
</code></pre>

<p><strong>git config</strong></p>

<p><code>git config</code> 命令用来配置本地安装的git</p>

<p>用法：</p>

<pre><code>git config user.name &lt;name&gt;
</code></pre>

<p>配置当前仓库修改提交作者名</p>

<pre><code>git config --global user.name &lt;name&gt;
</code></pre>

<p>通常情况下使用 &ndash;global 标记来配置本地所有仓库提交作者名</p>

<pre><code>git config --global user.email &lt;email&gt;
</code></pre>

<p>配置本地所有仓库提交email地址</p>

<pre><code>git config --global alias.&lt;alias-name&gt; &lt;git-command&gt;
</code></pre>

<p>为git命令创建简洁的别名，更多请参考：
<strong><a href="http://strivingboy.github.com/blog/2014/09/07/git-aliase/">让Git命令更简单（Git alias)</a></strong></p>

<p><strong>git add</strong></p>

<p><code>git add</code> 命令用来跟踪本地修改，为接下来的提交做准备</p>

<p>用法：</p>

<pre><code>git add &lt;file&gt;
</code></pre>

<p>跟踪对文件file的修改</p>

<pre><code>git add &lt;directory&gt;
</code></pre>

<p>跟踪对目录directory下所有修改</p>

<pre><code>git add .
</code></pre>

<p>跟踪本地工作目录下所有修改</p>

<p>例子：</p>

<pre><code>git add hello.txt
git commit
</code></pre>

<p><strong>git commit</strong></p>

<p><code>git commit</code>命令用来将本地跟踪的修改添加到本地仓库历史</p>

<p>用法：</p>

<pre><code>git commit
</code></pre>

<p>提交本地修改，启动文本编辑器，编辑提交信息</p>

<pre><code>git commit -m"message"
</code></pre>

<p>提交本地修改，直接编辑提交信息，不启动文本编辑器</p>

<pre><code>git commit -a 
</code></pre>

<p>提交本地工作目录下搜有修改，而不需要先 <code>git add</code>,相当于：<code>git add</code> 和 <code>git commit</code></p>

<pre><code>git commit -a -m"message"
</code></pre>

<p>同上直接编辑提交信息</p>

<p><strong>git status</strong></p>

<p><code>git status</code> 命令用于查看当前工作区和暂存区的状态信息</p>

<p>用法：</p>

<pre><code>git status
</code></pre>

<p>列出暂存过、未暂存过、未跟踪的文件</p>

<p>例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># On branch master
</span><span class='line'># Changes to be committed:
</span><span class='line'># (use "git reset HEAD &lt;file&gt;..." to unstage)
</span><span class='line'>#
</span><span class='line'>#modified: hello.txt
</span><span class='line'>#
</span><span class='line'># Changes not staged for commit:
</span><span class='line'># (use "git add &lt;file&gt;..." to update what will be committed)
</span><span class='line'># (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)
</span><span class='line'>#
</span><span class='line'>#new: test.txt
</span><span class='line'>#
</span><span class='line'># Untracked files:
</span><span class='line'># (use "git add &lt;file&gt;..." to include in what will be committed)
</span><span class='line'>#
</span></code></pre></td></tr></table></div></figure>


<p><strong>git log</strong></p>

<p>关于<code>git log</code> 请参考：<strong><a href="http://strivingboy.github.com/blog/2014/09/29/better-git-log/">更好的git log</a></strong></p>

<p>下一篇：<a href="http://strivingboy.github.com/blog/2014/08/09/git-ji-chu-er/">Git 使用基础(二)</a></p>
]]></content>
  </entry>
  
</feed>
